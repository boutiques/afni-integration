{"helptext": ["n itself.", "                  ++ wsinc5 interpolation is highly accurate and should", "                       reduce the smoothing artifacts from lower", "                       order interpolation methods (which are most", "                       visible if you interpolate an EPI time series", "                       to high resolution and then make an image of", "                       the voxel-wise variance).", "                  ++ On my Intel-based Mac, it takes about 2.5 s to do", "                       wsinc5 interpolation, per 1 million voxels output.", "                       For comparison, quintic interpolation takes about", "                       0.3 s per 1 million voxels: 8 times faster than wsinc5.", "                  ++ The '5' refers to the width of the sinc interpolation", "                       weights: plus/minus 5 grid points in each direction;", "                       this is a tensor product interpolation, for speed.", "", "TECHNICAL OPTIONS (used for fine control of the program):", "=================", " -nmatch nnn = Use at most 'nnn' scattered points to match the", "               datasets.  The smaller nnn is, the faster the matching", "               algorithm will run; however, accuracy may be bad if", "               nnn is too small.  If you end the 'nnn' value with the", "               '%' character, then that percentage of the base's", "               voxels will be used.", "               [Default == 47% of voxels in the weight mask]", "", " -nopad      = Do not use zero-padding on the base image.", "               [Default == zero-pad, if needed; -verb shows how much]", "", " -zclip      = Replace negative values in the input datasets (source & base)", "               with zero.  The intent is to clip off a small set of negative", "               values that may arise when using 3dresample (say) with", "               cubic interpolation.", "", " -conv mmm   = Convergence test is set to 'mmm' millimeters.", "               This doesn't mean that the results will be accurate", "               to 'mmm' millimeters!  It just means that the program", "               stops trying to improve the alignment when the optimizer", "               (NEWUOA) reports it has narrowed the search radius", "               down to this level.  [Default == 0.05 mm]", "", " -verb       = Print out verbose progress reports.", "               [Using '-VERB' will give even more prolix reports.]", " -quiet      = Don't print out verbose stuff.", " -usetemp    = Write intermediate stuff to disk, to economize on RAM.", "               Using this will slow the program down, but may make it", "               possible to register datasets that need lots of space.", "       **N.B.: Temporary files are written to the directory given", "               in environment variable TMPDIR, or in /tmp, or in ./", "               (preference in that order).  If the program crashes,", "               these files are named TIM_somethingrandom, and you", "               may have to delete them manually. (TIM=Temporary IMage)", "       **N.B.: If the program fails with a 'malloc failure' type of", "               message, then try '-usetemp' (malloc=memory allocator).", " -nousetemp  = Don't use temporary workspace on disk [the default].", "", " -check hhh  = After cost functional optimization is done, start at the", "               final parameters and RE-optimize using the new cost", "               function 'hhh'.  If the results are too different, a", "               warning message will be printed.  However, the final", "               parameters from the original optimization will be", "               used to create the output dataset. Using '-check'", "               increases the CPU time, but can help you feel sure", "               that the alignment process did not go wild and crazy.", "               [Default == no check == don't worry, be happy!]", "       **N.B.: You can put more than one function after '-check', as in", "                 -nmi -check mi hel crU crM", "               to register with Normalized Mutual Information, and", "               then check the results against 4 other cost functionals.", "       **N.B.: On the other hand, some cost functionals give better", "               results than others for specific problems, and so", "               a warning that 'mi' was significantly different than", "               'hel' might not actually mean anything useful (e.g.).", "", " ** PARAMETERS THAT AFFECT THE COST OPTIMIZATION STRATEGY **", " -onepass    = Use only the refining pass -- do not try a coarse", "               resolution pass first.  Useful if you know that only", "               small amounts of image alignment are needed.", "               [The default is to use both passes.]", " -twopass    = Use a two pass alignment strategy, first searching for", "               a large rotation+shift and then refining the alignment.", "               [Two passes are used by default for the first sub-brick]", "               [in the source dataset, and then one pass for the others.]", "               ['-twopass' will do two passes for ALL source sub-bricks.]", " -twoblur rr = Set the blurring radius for the first pass to 'rr'", "               millimeters.  [Default == 11 mm]", "       **N.B.: You may want to change this from the default if", "               your voxels are unusually small or unusually large", "               (e.g., outside the range 1-4 mm along each axis).", " -twofirst   = Use -twopass on the first image to be registered, and", "               then on all subsequent images from the source dataset,", "               use results from the first image's coarse pass to start", "               the fine pass.", "               (Useful when there may be large motions between the   )", "               (source and the base, but only small motions within   )", "               (the source dataset itself; since the coarse pass can )", "               (be slow, doing it only once makes sense in this case.)", "       **N.B.: [-twofirst is on by default; '-twopass' turns it off.]", " -twobest bb = In the coarse pass, use the best 'bb' set of initial", "               points to search for the starting point for the fine", "               pass.  If bb==0, then no search is made for the best", "               starting point, and the identity transformation is", "               used as the starting point.  [Default=5; min=0 max=22]", "       **N.B.: Setting bb=0 will make things run faster, but less reliably.", " -fineblur x = Set the blurring radius to use in the fine resolution", "               pass to 'x' mm.  A small amount (1-2 mm?) of blurring at", "               the fine step may help with convergence, if there is", "               some problem, especially if the base volume is very noisy.", "               [Default == 0 mm = no blurring at the final alignment pass]", "   **NOTES ON", "   **STRATEGY: * If you expect only small-ish (< 2 voxels?) image movement,", "                 then using '-onepass' or '-twobest 0' makes sense.", "               * If you expect large-ish image movements, then do not", "                 use '-onepass' or '-twobest 0'; the purpose of the", "                 '-twobest' parameter is to search for large initial", "                 rotations/shifts with which to start the coarse", "                 optimization round.", "               * If you have multiple sub-bricks in the source dataset,", "                 then the default '-twofirst' makes sense if you don't expect", "                 large mov"], "params": [{"param_range": [1000, 1007], "help_range": [1014, 1430]}, {"param_range": [1433, 1439], "help_range": [1447, 1559]}, {"param_range": [1562, 1568], "help_range": [1576, 1820]}, {"param_range": [1823, 1828], "help_range": [1837, 2213]}, {"param_range": [2216, 2221], "help_range": [2230, 2332]}, {"param_range": [2334, 2340], "help_range": [2348, 2378]}, {"param_range": [2380, 2388], "help_range": [2394, 3066]}, {"param_range": [3068, 3078], "help_range": [3082, 3134]}, {"param_range": [3137, 3143], "help_range": [3151, 3810]}, {"param_range": [3828, 3832], "help_range": [3811, 4325]}, {"param_range": [4327, 4335], "help_range": [4341, 4570]}, {"param_range": [4572, 4580], "help_range": [4586, 4931]}, {"param_range": [4933, 4941], "help_range": [4947, 5239]}, {"param_range": [5241, 5250], "help_range": [5255, 5833]}, {"param_range": [5835, 5843], "help_range": [5849, 6249]}], "previous": "3dAllineate_part3.json", "next": "3dAllineate_part5.json"}