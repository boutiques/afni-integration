{"helptext": ["flip angle -- for more details,", "       see http://dx.doi.org/10.1016/j.neuroimage.2010.11.020", "---------------------------------------------------------------------------", "  **** New (Summer 2013) program 3dQwarp is available to do nonlinear  ****", "  ***  alignment between a base and source dataset, including the use   ***", "  **   of 3dAllineate for the preliminary affine alignment.  If you are  **", "  *    interested, see the output of '3dQwarp -help' for the details.     *", "---------------------------------------------------------------------------", "", "COMMAND LINE OPTIONS:", "====================", " -base bbb   = Set the base dataset to be the #0 sub-brick of 'bbb'.", "               If no -base option is given, then the base volume is", "               taken to be the #0 sub-brick of the source dataset.", "               (Base must be stored as floats, shorts, or bytes.)", "", " -source ttt = Read the source dataset from 'ttt'.  If no -source", "   *OR*        (or -input) option is given, then the source dataset", " -input ttt    is the last argument on the command line.", "               (Source must be stored as floats, shorts, or bytes.)", "            ** 3dAllineate can register 2D datasets (single slice),", "               but both the base and source must be 2D -- you cannot", "               use this program to register a 2D slice into a 3D volume!", "            ** See the script @2dwarper.Allin for an example of using", "               3dAllineate to do slice-by-slice nonlinear warping to", "               align 3D volumes distorted by time-dependent magnetic", "               field inhomogeneities.", "", " ** NOTA BENE: The base and source dataset do NOT have to be defined **", " ** [that's]   on the same 3D grids; the alignment process uses the  **", " ** [Latin ]   coordinate systems defined in the dataset headers to  **", " ** [  for ]   make the match between spatial locations, rather than **", " ** [ NOTE ]   matching the 2 datasets on a voxel-by-voxel basis     **", " ** [ WELL ]   (as 3dvolreg and 3dWarpDrive do).                     **", " **       -->> However, this coordinate-based matching requires that **", " **            image volumes be defined on roughly the same patch of **", " **            of (x,y,z) space, in order to find a decent starting  **", " **            point for the transformation.  You might need to use  **", " **            the script @Align_Centers to do this, if the 3D       **", " **            spaces occupied by the images do not overlap much.    **", " **       -->> Or the '-cmass' option to this program might be       **", " **            sufficient to solve this problem, maybe, with luck.   **", " **            (Another reason why you should use align_epi_anat.py) **", " **       -->> If the coordinate system in the dataset headers is    **", " **            WRONG, then 3dAllineate will probably not work well!  **", "", " -prefix ppp = Output the resulting dataset to file 'ppp'.  If this", "   *OR*        option is NOT given, no dataset will be output!  The", " -out ppp      transformation matrix to align the source to the base will", "               be estimated, but not applied.  You can save the matrix", "               for later use using the '-1Dmatrix_save' option.", "        *N.B.: By default, the new dataset is computed on the grid of the", "                base dataset; see the '-master' and/or the '-mast_dxyz'", "                options to change this grid.", "        *N.B.: If 'ppp' is 'NULL', then no output dataset will be produced.", "                This option is for compatibility with 3dvolreg.", "", " -floatize   = Write result dataset as floats.  Internal calculations", " -float        are all done on float copies of the input datasets.", "               [Default=convert output dataset to data format of  ]", "               [        source dataset; if the source dataset was ]", "               [        shorts with a scale factor, then the new  ]", "               [        dataset will get a scale factor as well;  ]", "               [        if the source dataset was shorts with no  ]", "               [        scale factor, the result will be unscaled.]", "", " -1Dparam_save ff   = Save the warp parameters in ASCII (.1D) format into", "                      file 'ff' (1 row per sub-brick in source).", "                    * A historical synonym for this option is '-1Dfile'.", "                    * At the top of the saved 1D file is a #comment line", "                      listing the names of the parameters; those parameters", "                      that are fixed (e.g., via '-parfix') will be marked", "                      by having their symbolic names end in the '$' character.", "                      You can use '1dcat -nonfixed' to remove these columns", "                      from the 1D file if you just want to further process the", "                      varying parameters somehow (e.g., 1dsvd).", "                    * However, the '-1Dparam_apply' option requires the", "                      full list of parameters, including those that were", "                      fixed, in order to work properly!", "", " -1Dparam_apply aa  = Read warp parameters from file 'aa', apply them to ", "                      the source dataset, and produce a new dataset.", "                      (Must also use the '-prefix' option for this to work!  )", "                      (In this mode of operation, there is no optimization of)", "                      (the cost functional by changing the warp parameters;  )", "                      (previously computed parameters are applied directly.  )", "               *N.B.: A historical synonym for this is '-1Dapply'.", "               *N.B.: If you use -1Dparam_apply, you may also want to use", "                       -master to control the grid on which the new", "                       dataset is written -- the base dataset from the", "                       original 3dAllineate run would be a good possibility.", "                       Otherwise, the new dataset will be written out on the", "                       3D grid coverage of the source dataset, and this", "                       might result in clipping off part of the image.", "               *N.B.: Each row in the 'aa' file contains the parameters for", "                       transforming one sub-brick in the source dataset.", "                       If there are more sub-bricks in the source dataset", "                       than there are rows in the 'aa' file, then the last", "                       row is used repeatedly.", "               *N.B.: A trick to use 3dAllineate to resample a dataset to", "                       a finer grid spacing:", "                         3dAllineate -input dataset+orig         \\", "                                     -master template+orig       \\", "                                     -prefix newdataset          \\", "                                     -final wsinc5               \\", "                                     -1Dparam_apply '1D: 12@0'\\'  ", "                       Here, the identity transformation is specified", "                       by giving all 12 affine parameters as 0 (note", "                       the extra \\' at the end of the '1D: 12@0' input!).", "                     ** You can also use the word 'IDENTITY' in place of", "                        '1D: 12@0'\\' (to indicate the identity transformation).", "              **N.B.: Some expert options for modifying how the wsinc5", "                       method works are described far below, if you use", "                       '-HELP' instead of '-help'.", "            ****N.B.: The interpolation method used to produce a dataset", "                       is always given via the '-final' option, NOT via", "                       '-interp'.  If you forget this and use '-interp'", "                       along with one of the 'apply' options, this program", "                       will chastise you (gently) and change '-final'", "                       to match what the '-interp' input.", "", " -1Dmatrix_save ff  = Save the transformation matrix for each sub-brick into", "                      file 'ff' (1 row per sub-brick in the source dataset).", "                      If 'ff' does NOT end in '.1D', then the program will", "                      append '.aff12.1D' to 'ff' to make the output filename.", "               *N.B.: This matrix is the coordinate transformation from base", "                       to source DICOM coordinates. In other terms:", "                          Xin = Xsource = M Xout = M Xbase", "                                   or", "                          Xout = Xbase = inv(M) Xin = inv(M) Xsource", "                       where Xin or Xsource is the 4x1 coordinates of a", "                       location in the input volume. Xout is the ", "                       coordinate of that same location in the output volume.", "                       Xbase is the coordinate of the corresponding location", "                       in the base dataset. M is ff augmented by a 4th row of", "            "], "params": [{"param_range": [1000, 1006], "help_range": [999, 2804]}, {"param_range": [2807, 2814], "help_range": [2821, 2941]}, {"param_range": [2943, 2947], "help_range": [2942, 3481]}, {"param_range": [3484, 3493], "help_range": [3498, 3552]}, {"param_range": [3554, 3560], "help_range": [3553, 4027]}, {"param_range": [4030, 4043], "help_range": [4051, 4962]}, {"param_range": [4965, 4979], "help_range": [4986, 7778]}], "previous": "3dAllineate_part1.json", "next": "3dAllineate_part3.json"}