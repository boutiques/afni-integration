{"helptext": ["ly '1D: 12@0'\\'  ", "                       Here, the identity transformation is specified", "                       by giving all 12 affine parameters as 0 (note", "                       the extra \\' at the end of the '1D: 12@0' input!).", "                     ** You can also use the word 'IDENTITY' in place of", "                        '1D: 12@0'\\' (to indicate the identity transformation).", "              **N.B.: Some expert options for modifying how the wsinc5", "                       method works are described far below, if you use", "                       '-HELP' instead of '-help'.", "            ****N.B.: The interpolation method used to produce a dataset", "                       is always given via the '-final' option, NOT via", "                       '-interp'.  If you forget this and use '-interp'", "                       along with one of the 'apply' options, this program", "                       will chastise you (gently) and change '-final'", "                       to match what the '-interp' input.", "", " -1Dmatrix_save ff  = Save the transformation matrix for each sub-brick into", "                      file 'ff' (1 row per sub-brick in the source dataset).", "                      If 'ff' does NOT end in '.1D', then the program will", "                      append '.aff12.1D' to 'ff' to make the output filename.", "               *N.B.: This matrix is the coordinate transformation from base", "                       to source DICOM coordinates. In other terms:", "                          Xin = Xsource = M Xout = M Xbase", "                                   or", "                          Xout = Xbase = inv(M) Xin = inv(M) Xsource", "                       where Xin or Xsource is the 4x1 coordinates of a", "                       location in the input volume. Xout is the ", "                       coordinate of that same location in the output volume.", "                       Xbase is the coordinate of the corresponding location", "                       in the base dataset. M is ff augmented by a 4th row of", "                       [0 0 0 1], X. is an augmented column vector [x,y,z,1]'", "                       To get the inverse matrix inv(M)", "                       (source to base), use the cat_matvec program, as in", "                         cat_matvec fred.aff12.1D -I", "", " -1Dmatrix_apply aa = Use the matrices in file 'aa' to define the spatial", "                      transformations to be applied.  Also see program", "                      cat_matvec for ways to manipulate these matrix files.", "               *N.B.: You probably want to use either -base or -master", "                      with either *_apply option, so that the coordinate", "                      system that the matrix refers to is correctly loaded.", "                     ** You can also use the word 'IDENTITY' in place of a", "                        filename to indicate the identity transformation --", "                        presumably for the purpose of resampling the source", "                        dataset to a new grid.", "", "  * The -1Dmatrix_* options can be used to save and re-use the transformation *", "  * matrices.  In combination with the program cat_matvec, which can multiply *", "  * saved transformation matrices, you can also adjust these matrices to      *", "  * other alignments.                                                         *", "", "  * The script 'align_epi_anat.py' uses 3dAllineate and 3dvolreg to align EPI *", "  * datasets to T1-weighted anatomical datasets, using saved matrices between *", "  * the two programs.  This script is our currently recommended method for    *", "  * doing such intra-subject alignments.                                      *", "", " -cost ccc   = Defines the 'cost' function that defines the matching", "               between the source and the base; 'ccc' is one of", "                ls   *OR*  leastsq         = Least Squares [Pearson Correlation]", "                mi   *OR*  mutualinfo      = Mutual Information [H(b)+H(s)-H(b,s)]", "                crM  *OR*  corratio_mul    = Correlation Ratio (Symmetrized*)", "                nmi  *OR*  norm_mutualinfo = Normalized MI [H(b,s)/(H(b)+H(s))]", "                hel  *OR*  hellinger       = Hellinger metric", "                crA  *OR*  corratio_add    = Correlation Ratio (Symmetrized+)", "                crU  *OR*  corratio_uns    = Correlation Ratio (Unsym)", "               You can also specify the cost functional using an option", "               of the form '-mi' rather than '-cost mi', if you like", "               to keep things terse and cryptic (as I do).", "               [Default == '-hel' (for no good reason, but it sounds nice).]", "", " -interp iii = Defines interpolation method to use during matching", "               process, where 'iii' is one of", "                 NN      *OR* nearestneighbour *OR nearestneighbor", "                 linear  *OR* trilinear", "                 cubic   *OR* tricubic", "                 quintic *OR* triquintic", "               Using '-NN' instead of '-interp NN' is allowed (e.g.).", "               Note that using cubic or quintic interpolation during", "               the matching process will slow the program down a lot.", "               Use '-final' to affect the interpolation method used", "               to produce the output dataset, once the final registration", "               parameters are determined.  [Default method == 'linear'.]", "            ** N.B.: Linear interpolation is used during the coarse", "                     alignment pass; the selection here only affects", "                     the interpolation method used during the second", "                     (fine) alignment pass.", "            ** N.B.: '-interp' does NOT define the final method used", "                     to produce the output dataset as warped from the", "                     input dataset.  If you want to do that, use '-final'.", "", " -final iii  = Defines the interpolation mode used to create the", "               output dataset.  [Default == 'cubic']", "            ** N.B.: For '-final' ONLY, you can use 'wsinc5' to specify", "                       that the final interpolation be done using a", "                       weighted sinc interpolation method.  This method", "                       is so SLOW that you aren't allowed to use it for", "                       the registration itself.", "                  ++ wsinc5 interpolation is highly accurate and should", "                       reduce the smoothing artifacts from lower", "                       order interpolation methods (which are most", "                       visible if you interpolate an EPI time series", "                       to high resolution and then make an image of", "                       the voxel-wise variance).", "                  ++ On my Intel-based Mac, it takes about 2.5 s to do", "                       wsinc5 interpolation, per 1 million voxels output.", "                       For comparison, quintic interpolation takes about", "                       0.3 s per 1 million voxels: 8 times faster than wsinc5.", "                  ++ The '5' refers to the width of the sinc interpolation", "                       weights: plus/minus 5 grid points in each direction;", "                       this is a tensor product interpolation, for speed.", "", "TECHNICAL OPTIONS (used for fine control of the program):", "=================", " -nmatch nnn = Use at most 'nnn' scattered points to match the", "               datasets.  The smaller nnn is, the faster the matching", "               algorithm will run; however, accuracy may be bad if", "               nnn is too small.  If you end the 'nnn' value with the", "               '%' character, then that percentage of the base's", "               voxels will be used.", "               [Default == 47% of voxels in the weight mask]", "", " -nopad      = Do not use zero-padding on the base image.", "               [Default == zero-pad, if needed; -verb shows how much]", "", " -zclip      = Replace negative values in the input datasets (source & base)", "               with zero.  The intent is to clip off a small set of negative", "               values that may arise when using 3dresample (say) with", "               cubic interpolation.", "", " -conv mmm   = Convergence test is set to 'mmm' millimeters.", "               This doesn't mean that the results will be accurate", "               to 'mmm' millimeters!  It just mean"], "params": [{"param_range": [1000, 1014], "help_range": [1021, 2249]}, {"param_range": [2252, 2267], "help_range": [2273, 3607]}, {"param_range": [3610, 3615], "help_range": [3624, 4551]}, {"param_range": [4554, 4561], "help_range": [4568, 5740]}, {"param_range": [5743, 5749], "help_range": [5757, 7180]}], "previous": "3dAllineate_part2.json", "next": "3dAllineate_part4.json"}