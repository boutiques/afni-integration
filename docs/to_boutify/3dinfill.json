{"helptext": ["A program to fill holes in a volumes.", "", "     3dinfill    <-input DSET> ", "", "Options:", "   -input  DSET: Fill volume DSET", "   -prefix PREF: Use PREF for output prefix.", "   -Niter NITER: Do not allow the fill function to do more than NITER", "                 passes. A -1 (default) lets the function go to a maximum", "                 of 500 iterations. You will be warned if you run our of ", "                 iterations and holes persist.", "   -blend METH: Sets method for assigning a value to a hole.", "                MODE: Fill with most frequent neighbor value. Use MODE when", "                      filling integral valued data such as ROIs or atlases.", "                AVG: Fill with average of neighboring values.", "                AUTO: Use MODE if DSET is integral, AVG otherwise.", "                SOLID: No blending, brutish fill. See also -minhits", "                SOLID_CLEAN: SOLID, followed by removal of dangling chunks", "                             Dangling chunks are defined as non-zero regions", "                             that surround lesser holes, i.e. holes that have", "                             less than MH. The cleanup step is not iterative", "                             though, and you are most likely better off using", "                             option -ed to do the cleanup.", "   -minhits MH: Crietrion for considering a zero voxel to be a hole", "                MH refers to the total number of directions alogn which a", "                zero voxel is considered surrounded by non zero values.", "                a value of 1 is the least strict criterion, and a value of 3", "                is the strictest. ", "                This parameter can only be used with -blend SOLID", "   -ed N V: Erode N times then dialate N times to get rid of hanging chunks.", "            Values filled in by this process get value V.", "   -mask MSET: Provide mask dataset to select subset of input.", "   -mask_range BOT TOP: Specify the range of values to consider from MSET.", "                        Default is anything non-zero.", "   -mrange BOT TOP: Same as option -mask_range", "   -cmask CMASK: Provide cmask expression. Voxels where expression is 0", "                 are excluded from computations. For example:", "            -cmask '-a T1.div.r+orig -b T1.uni.r+orig -expr step(a/b-10)'", "   NOTE: For the moment, masking is only implemented for the SOLID* fill", "         method.", "", "Example 1:", "Starting from a whole head mask that has some big holes in it where CSF and ", "cavities are. Fill the inside of the mask and remove dangling chunks in the", "end with -ed ", "        3dinfill -blend SOLID -ed 3 1 -prefix filledmask \\", "                 -minhits 2 -input holymask+orig.  ", "", "This program will be slow for high res datasets with large holes.", "If you are trying to fill holes in masks, consider also:", "  3dmask_tool -fill_holes ", ""], "params": [{"param": "-input", "line_start": 5, "length": 1, "param_range": [84, 90], "help": "Fill volume DSET", "help_range": [98, 114]}, {"param": "-prefix", "line_start": 6, "length": 1, "param_range": [118, 125], "help": "Use PREF for output prefix.", "help_range": [132, 159]}, {"param": "-Niter", "line_start": 7, "length": 4, "param_range": [163, 169], "help": "Do not allow the fill function to do more than NITER\n                 passes. A -1 (default) lets the function go to a maximum\n                 of 500 iterations. You will be warned if you run our of \n                 iterations and holes persist.", "help_range": [177, 424]}, {"param": "-blend", "line_start": 11, "length": 12, "param_range": [428, 434], "help": "Sets method for assigning a value to a hole.\n                MODE: Fill with most frequent neighbor value. Use MODE when\n                      filling integral valued data such as ROIs or atlases.\n                AVG: Fill with average of neighboring values.\n                AUTO: Use MODE if DSET is integral, AVG otherwise.\n                SOLID: No blending, brutish fill. See also -minhits\n                SOLID_CLEAN: SOLID, followed by removal of dangling chunks\n                             Dangling chunks are defined as non-zero regions\n                             that surround lesser holes, i.e. holes that have\n                             less than MH. The cleanup step is not iterative\n                             though, and you are most likely better off using\n                             option -ed to do the cleanup.", "help_range": [441, 1278]}, {"param": "-minhits", "line_start": 23, "length": 6, "param_range": [1282, 1290], "help": "Crietrion for considering a zero voxel to be a hole\n                MH refers to the total number of directions alogn which a\n                zero voxel is considered surrounded by non zero values.\n                a value of 1 is the least strict criterion, and a value of 3\n                is the strictest. \n                This parameter can only be used with -blend SOLID", "help_range": [1295, 1670]}, {"param": "-ed", "line_start": 29, "length": 2, "param_range": [1674, 1677], "help": "Erode N times then dialate N times to get rid of hanging chunks.\n            Values filled in by this process get value V.", "help_range": [1683, 1805]}, {"param": "-mask", "line_start": 31, "length": 1, "param_range": [1809, 1814], "help": "Provide mask dataset to select subset of input.", "help_range": [1821, 1868]}, {"param": "-mask_range", "line_start": 32, "length": 2, "param_range": [1872, 1883], "help": "Specify the range of values to consider from MSET.\n                        Default is anything non-zero.", "help_range": [1893, 1997]}, {"param": "-mrange", "line_start": 34, "length": 1, "param_range": [2001, 2008], "help": "Same as option -mask_range", "help_range": [2018, 2044]}, {"param": "-cmask", "line_start": 35, "length": null, "param_range": [2048, 2054], "help": "Provide cmask expression. Voxels where expression is 0\n                 are excluded from computations. For example:\n            -cmask '-a T1.div.r+orig -b T1.uni.r+orig -expr step(a/b-10)'\n   NOTE: For the moment, masking is only implemented for the SOLID* fill\n         method.\n\nExample 1:\nStarting from a whole head mask that has some big holes in it where CSF and \ncavities are. Fill the inside of the mask and remove dangling chunks in the\nend with -ed \n        3dinfill -blend SOLID -ed 3 1 -prefix filledmask \\\n                 -minhits 2 -input holymask+orig.  \n\nThis program will be slow for high res datasets with large holes.\nIf you are trying to fill holes in masks, consider also:\n  3dmask_tool -fill_holes", "help_range": [2062, 2782]}]}