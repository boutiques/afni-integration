{"helptext": ["  = Use -twopass on the first image to be registered, and", "               then on all subsequent images from the source dataset,", "               use results from the first image's coarse pass to start", "               the fine pass.", "               (Useful when there may be large motions between the   )", "               (source and the base, but only small motions within   )", "               (the source dataset itself; since the coarse pass can )", "               (be slow, doing it only once makes sense in this case.)", "       **N.B.: [-twofirst is on by default; '-twopass' turns it off.]", " -twobest bb = In the coarse pass, use the best 'bb' set of initial", "               points to search for the starting point for the fine", "               pass.  If bb==0, then no search is made for the best", "               starting point, and the identity transformation is", "               used as the starting point.  [Default=5; min=0 max=22]", "       **N.B.: Setting bb=0 will make things run faster, but less reliably.", " -fineblur x = Set the blurring radius to use in the fine resolution", "               pass to 'x' mm.  A small amount (1-2 mm?) of blurring at", "               the fine step may help with convergence, if there is", "               some problem, especially if the base volume is very noisy.", "               [Default == 0 mm = no blurring at the final alignment pass]", "   **NOTES ON", "   **STRATEGY: * If you expect only small-ish (< 2 voxels?) image movement,", "                 then using '-onepass' or '-twobest 0' makes sense.", "               * If you expect large-ish image movements, then do not", "                 use '-onepass' or '-twobest 0'; the purpose of the", "                 '-twobest' parameter is to search for large initial", "                 rotations/shifts with which to start the coarse", "                 optimization round.", "               * If you have multiple sub-bricks in the source dataset,", "                 then the default '-twofirst' makes sense if you don't expect", "                 large movements WITHIN the source, but expect large motions", "                 between the source and base.", "               * '-twopass' re-starts the alignment process for each sub-brick", "                 in the source dataset -- this option can be time consuming,", "                 and is really intended to be used when you might expect large", "                 movements between sub-bricks; for example, when the different", "                 volumes are gathered on different days.  For most purposes,", "                 '-twofirst' (the default process) will be adequate and faster,", "                 when operating on multi-volume source datasets.", "", " -cmass        = Use the center-of-mass calculation to bracket the shifts.", "                   [This option is OFF by default]", "                 If given in the form '-cmass+xy' (for example), means to", "                 do the CoM calculation in the x- and y-directions, but", "                 not the z-direction.", " -nocmass      = Don't use the center-of-mass calculation. [The default]", "                  (You would not want to use the C-o-M calculation if the  )", "                  (source sub-bricks have very different spatial locations,)", "                  (since the source C-o-M is calculated from all sub-bricks)", " **EXAMPLE: You have a limited coverage set of axial EPI slices you want to", "            register into a larger head volume (after 3dSkullStrip, of course).", "            In this case, '-cmass+xy' makes sense, allowing CoM adjustment", "            along the x = R-L and y = A-P directions, but not along the", "            z = I-S direction, since the EPI doesn't cover the whole brain", "            along that axis.", "", " -autoweight = Compute a weight function using the 3dAutomask", "               algorithm plus some blurring of the base image.", "       **N.B.: '-autoweight+100' means to zero out all voxels", "                 with values below 100 before computing the weight.", "               '-autoweight**1.5' means to compute the autoweight", "                 and then raise it to the 1.5-th power (e.g., to", "                 increase the weight of high-intensity regions).", "               These two processing steps can be combined, as in", "                 '-autoweight+100**1.5'", "               ** Note that that '**' must be enclosed in quotes;", "                  otherwise, the shell will treat it as a wildcard", "                  and you will get an error message before 3dAllineate", "                  even starts!!", "       **N.B.: Some cost functionals do not allow -autoweight, and", "               will use -automask instead.  A warning message", "               will be printed if you run into this situation.", "               If a clip level '+xxx' is appended to '-autoweight',", "               then the conversion into '-automask' will NOT happen.", "               Thus, using a small positive '+xxx' can be used trick", "               -autoweight into working on any cost functional.", " -automask   = Compute a mask function, which is like -autoweight,", "               but the weight for a voxel is set to either 0 or 1.", "       **N.B.: '-automask+3' means to compute the mask function, and", "               then dilate it outwards by 3 voxels (e.g.).", "               ** Note that '+' means something very different", "                  for '-automask' and '-autoweight'!!", " -autobox    = Expand the -automask function to enclose a rectangular", "               box that holds the irregular mask.", "       **N.B.: This is the default mode of operation!", "               For intra-modality registration, '-autoweight' may be better!", "             * If the cost functional is 'ls', then '-autoweight' will be", "               the default, instead of '-autobox'.", " -nomask     = Don't compute the autoweight/mask; if -weight is not", "               also used, then every voxel will be counted equally.", " -weight www = Set the weighting for each voxel in the base dataset;", "               larger weights mean that voxel counts more in the cost", "               function.", "       **N.B.: The weight dataset must be defined on the same grid as", "               the base dataset.", "       **N.B.: Even if a method does not allow -autoweight, you CAN", "               use a weight dataset that is not 0/1 valued.  The", "               risk is yours, of course (!*! as always in AFNI !*!).", " -wtprefix p = Write the weight volume to disk as a dataset with", "               prefix name 'p'.  Used with '-autoweight/mask', this option", "               lets you see what voxels were important in the algorithm.", " -emask ee   = This option lets you specify a mask of voxels to EXCLUDE from", "               the analysis. The voxels where the dataset 'ee' is nonzero", "               will not be included (i.e., their weights will be set to zero).", "             * Like all the weight options, it applies in the base image", "               coordinate system.", "             * Like all the weight options, it means nothing if you are using", "               one of the 'apply' options.", "", "    Method  Allows -autoweight", "    ------  ------------------", "     ls     YES", "     mi     NO", "     crM    YES", "     nmi    NO", "     hel    NO", "     crA    YES", "     crU    YES", "", " -source_mask sss = Mask the source (input) dataset, using 'sss'.", " -source_automask = Automatically mask the source dataset.", "                      [By default, all voxels in the source]", "                      [dataset are used in the matching.   ]", "            **N.B.: You can also use '-source_automask+3' to dilate", "                    the default source automask outward by 3 voxels.", "", " -warp xxx   = Set the warp type to 'xxx', which is one of", "                 shift_only         *OR* sho =  3 parameters", "                 shift_rotate       *OR* shr =  6 parameters", "                 shift_rotate_scale *OR* srs =  9 parameters", "                 affine_general     *OR* aff = 12 parameters", "               [Default = affine_general, which includes image]", "               [      shifts, rotations, scaling, and shearing]", "", " -warpfreeze = Freeze the non-rigid body parameters (those past #6)", "               after doing the first sub-brick.  Subsequent volumes", "               will have the same spatial distortions as sub-brick #0,", "               plus rigid body motions only.", "", " -replacebase   = If the source has more than one sub-brick, and this", "                  option is turned on, then after the #0 sub-brick is", "                  aligned to the base, the aligned #0 sub-brick is used", "                  as the base image for subsequent source sub-bricks.", "", " -replacemeth m = After sub-brick"], "params": [{"param_range": [1000, 1009], "help_range": [1014, 2632]}, {"param_range": [2635, 2641], "help_range": [2651, 2943]}, {"param_range": [2945, 2953], "help_range": [2961, 3654]}, {"param_range": [3657, 3668], "help_range": [3671, 4909]}, {"param_range": [4911, 4920], "help_range": [4925, 5288]}, {"param_range": [5290, 5298], "help_range": [5304, 5664]}, {"param_range": [5666, 5673], "help_range": [5680, 5800]}, {"param_range": [5802, 5809], "help_range": [5816, 6269]}, {"param_range": [6271, 6280], "help_range": [6285, 6482]}, {"param_range": [6484, 6490], "help_range": [6498, 7112]}, {"param_range": [7115, 7127], "help_range": [7134, 7179]}, {"param_range": [7181, 7197], "help_range": [7200, 7497]}], "previous": "3dAllineate_part4.json", "next": "3dAllineate_part6.json"}