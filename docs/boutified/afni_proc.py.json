{
    "command-line": "afni_proc.py __REGRESS_STIM_FILES__ __DSETS__ __REGRESS_STIM_TIMES__ __REGRESS_STIM_LABELS__ __REGRESS_OPTS_3DD__ __DO_BLOCK__ __RICOR_REGS__ __REGRESS_APPLY_MOT_TYPES__ __REGRESS_RUN_CLUSTSIM__ __ALIGN_OPTS_AEA__ __REGRESS_STIM_TYPES__ __REGRESS_BASIS_MULTI__ __BLOCKS__ __SURF_ANAT__ __SURF_SPEC__ __MASK_SEGMENT_ERODE__ __MASK_SEGMENT_ANAT__ __REGRESS_ROI__ __ANAT_FOLLOWER_ERODE__ __REGRESS_MAKE_CORR_VOLS__ __E__ __REGRESS_ROI_PC_PER_RUN__ __DSETS_ME_ECHO__ __DSETS_ME_RUN__ __ECHO_TIMES__ __COMBINE_METHOD__ __MASK_EPI_ANAT__ __BLUR_IN_MASK__ __ASK_ME__ __GIANT_MOVE__ __HELP__ __HIST__ __REQUIRES_AFNI_VERSION__ __REQUIRES_AFNI_HIST__ __SHOW_VALID_OPTS__ __VER__ __ANAT_FOLLOWER__ __ANAT_FOLLOWER_ROI__ __ANAT_HAS_SKULL__ __ANAT_UNIFORM_METHOD__ __ANAT_OPTS_UNIF__ __ANAT_UNIF_GM__ __BASH__ __CHECK_AFNI_VERSION__ __CHECK_RESULTS_DIR__ __CHECK_SETUP_ERRORS__ __COPY_ANAT__ __COPY_FILES__ __EXECUTE__ __GEN_EPI_REVIEW__ __NO_EPI_REVIEW__ __KEEP_RM_FILES__ __MOVE_PREPROC_FILES__ __NO_PROC_COMMAND__ __OUT_DIR__ __OUTLIER_COUNT__ __OUTLIER_LEGENDRE__ __OUTLIER_POLORT__ __RADIAL_CORRELATE__ __REG_ECHO__ __REMOVE_PREPROC_FILES__ __SCRIPT__ __SCR_OVERWRITE__ __SEP_CHAR__ __SUBJ_CURLY__ __SUBJ_ID__ __TEST_FOR_DSETS__ __TEST_STIM_FILES__ __VERB__ __WRITE_3DD_PREFIX__ __WRITE_3DD_SCRIPT__ __WRITE_PPI_3DD_SCRIPTS__ __REGRESS_PPI_STIM_FILES__ __REGRESS_PPI_STIM_LABELS__ __TCAT_PRESS_WARN_LIMIT__ __TCAT_REMOVE_FIRST_TRS__ __TCAT_REMOVE_LAST_TRS__ __DESPIKE_MASK__ __DESPIKE_NEW__ __DESPIKE_OPTS_3DDES__ __RICOR_DATUM__ __RICOR_POLORT__ __RICOR_REGRESS_METHOD__ __RICOR_REGRESS_SOLVER__ __RICOR_REGS_NFIRST__ __RICOR_REGS_RM_NLAST__ __TSHIFT_ALIGN_TO__ __TSHIFT_INTERP__ __TSHIFT_OPTS_TS__ __BLIP_FORWARD_DSET__ __BLIP_REVERSE_DSET__ __BLIP_OPTS_QW__ __TLRC_ANAT__ __TLRC_BASE__ __TLRC_NL_WARP__ __TLRC_NL_WARPED_DSETS__ __TLRC_NL_AWPY_RM__ __TLRC_NO_SS__ __TLRC_OPTS_AT__ __TLRC_RMODE__ __TLRC_SUFFIX__ __ALIGN_EPI_EXT_DSET__ __ALIGN_EPI_STRIP_METHOD__ __ALIGN_UNIFIZE_EPI__ __VOLREG_ALIGN_E2A__ __VOLREG_ALIGN_TO__ __VOLREG_BASE_DSET__ __VOLREG_BASE_IND__ __VOLREG_GET_ALLCOSTX__ __VOLREG_COMPUTE_TSNR__ __VOLREG_INTERP__ __VOLREG_MOTSIM__ __VOLREG_OPTS_MS__ __VOLREG_OPTS_VR__ __VOLREG_NO_EXTENT_MASK__ __VOLREG_REGRESS_PER_RUN__ __VOLREG_TLRC_ADWARP__ __VOLREG_TLRC_WARP__ __VOLREG_WARP_DXYZ__ __VOLREG_ZPAD__ __SURF_A__ __SURF_B__ __SURF_BLUR_FWHM__ __BLUR_FILTER__ __BLUR_IN_AUTOMASK__ __BLUR_OPTS_BIM__ __BLUR_OPTS_MERGE__ __BLUR_SIZE__ __BLUR_TO_FWHM__ __BLUR_OPTS_B2FW__ __MASK_APPLY__ __MASK_DILATE__ __MASK_IMPORT__ __MASK_INTERSECT__ __MASK_UNION__ __MASK_RM_SEGSY__ __MASK_TEST_OVERLAP__ __MASK_TYPE__ __COMBINE_OPTS_TEDANA__ __COMBINE_OPTS_TEDWRAP__ __COMBINE_TEDANA_PATH__ __SCALE_MAX_VAL__ __SCALE_NO_MAX__ __REGRESS_3DD_STOP__ __REGRESS_ANATICOR__ __REGRESS_ANATICOR_LABEL__ __REGRESS_ANATICOR_RADIUS__ __REGRESS_ANATICOR_FAST__ __REGRESS_ANATICOR_FWHM__ __REGRESS_APPLY_MASK__ __REGRESS_APPLY_RICOR__ __REGRESS_BANDPASS__ __REGRESS_BASIS__ __REGRESS_BASIS_NORMALL__ __REGRESS_CENSOR_EXTERN__ __REGRESS_CENSOR_MOTION__ __REGRESS_CENSOR_FIRST_TRS__ __REGRESS_CENSOR_PREV__ __REGRESS_CENSOR_OUTLIERS__ __REGRESS_COMPUTE_GCOR__ __REGRESS_COMPUTE_TSNR__ __REGRESS_FOUT__ __REGRESS_MAKE_CBUCKET__ __REGRESS_MOT_AS_ORT__ __STIM_FILE__ __ORTVEC__ __REGRESS_MOTION_PER_RUN__ __REGRESS_SKIP_FIRST_OUTLIERS__ __REGRESS_COMPUTE_FITTS__ __REGRESS_CORMAT_WARNINGS__ __REGRESS_EST_BLUR_EPITS__ __REGRESS_EST_BLUR_ERRTS__ __REGRESS_ERRTS_PREFIX__ __REGRESS_FITTS_PREFIX__ __REGRESS_GLOBAL_TIMES__ __REGRESS_LOCAL_TIMES__ __REGRESS_IRESP_PREFIX__ __IRESP__ __REGRESS_MAKE_IDEAL_SUM__ __REGRESS_MOTION_FILE__ __REGRESS_NO_FITTS__ __REGRESS_NO_IDEAL_SUM__ __REGRESS_NO_IDEALS__ __REGRESS_NO_IRESP__ __REGRESS_NO_MASK__ __REGRESS_NO_MOTION__ __REGRESS_NO_MOTION_DEMEAN__ __REGRESS_NO_MOTION_DERIV__ __REGRESS_OPTS_REML__ __REGRESS_POLORT__ __REGRESS_REML_EXEC__ __REGRESS_ROI_PC__ __REGRESS_RSFC__ __REGRESS_RONI__ __REGRESS_EXTRA_STIM_FILES__ __REGRESS_EXTRA_STIM_LABELS__ __REGRESS_STIM_TIMES_OFFSET__ __REGRESS_USE_STIM_FILES__ __REGRESS_OPTS_CS__ __REGRESS_CS_NN__",
    "description": "tool description",
    "inputs": [
        {
            "command-line-flag": "-regress_stim_files",
            "description": "-regress_stim_files stims.1D  or without any wildcard, the .HEAD suffix is not needed:  afni_proc.py -dsets epiRT_r1+orig epiRT_r2+orig epiRT_r3+orig \\",
            "id": "__REGRESS_STIM_FILES__",
            "name": "__REGRESS_STIM_FILES__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_STIM_FILES__"
        },
        {
            "command-line-flag": "-dsets",
            "description": "-dsets sb23/epi_r??+orig.HEAD                      \\ -tcat_remove_first_trs 3                           \\",
            "id": "__DSETS__",
            "name": "__DSETS__",
            "optional": true,
            "type": "String",
            "value-key": "__DSETS__"
        },
        {
            "command-line-flag": "-regress_stim_times",
            "description": "-regress_stim_times sb23/stim_files/blk_times.*.1D \\ -regress_basis 'BLOCK(30,1)'  Example 3. (no longer) The current class example.  ~2~  Copy the anatomy into the results directory, register EPI data to the last TR, specify stimulus labels, compute blur estimates, and provide GLT options directly to 3dDeconvolve.  The GLTs will be ignored after this, as they take up too many lines.  afni_proc.py -subj_id sb23.blk                             \\",
            "id": "__REGRESS_STIM_TIMES__",
            "name": "__REGRESS_STIM_TIMES__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_STIM_TIMES__"
        },
        {
            "command-line-flag": "-regress_stim_labels",
            "description": "-regress_stim_labels tneg tpos tneu eneg epos      \\ eneu fneg fpos fneu           \\ -regress_basis 'BLOCK(30,1)'                       \\",
            "id": "__REGRESS_STIM_LABELS__",
            "name": "__REGRESS_STIM_LABELS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_STIM_LABELS__"
        },
        {
            "command-line-flag": "-regress_opts_3dD",
            "description": "-regress_opts_3dD                                  \\ -gltsym 'SYM: +eneg -fneg'                     \\ -glt_label 1 eneg_vs_fneg                      \\ -gltsym 'SYM: 0.5*fneg 0.5*fpos -1.0*fneu'     \\ -glt_label 2 face_contrast                     \\ -gltsym 'SYM: tpos epos fpos -tneg -eneg -fneg'\\ -glt_label 3 pos_vs_neg                        \\ -regress_est_blur_epits                            \\ -regress_est_blur_errts  Example 4. Similar to 3, but specify the processing blocks. ~2~  Adding despike and tlrc, and removing tshift.  Note that the tlrc block is to run @auto_tlrc on the anat.  Ignore the GLTs.  afni_proc.py -subj_id sb23.e4.blocks                       \\",
            "id": "__REGRESS_OPTS_3DD__",
            "name": "__REGRESS_OPTS_3DD__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_OPTS_3DD__"
        },
        {
            "command-line-flag": "-do_block",
            "description": "-do_block despike ricor                 \\ -tcat_remove_first_trs 3                \\",
            "id": "__DO_BLOCK__",
            "name": "__DO_BLOCK__",
            "optional": true,
            "type": "String",
            "value-key": "__DO_BLOCK__"
        },
        {
            "command-line-flag": "-ricor_regs",
            "description": "-ricor_regs_nfirst 3                    \\",
            "id": "__RICOR_REGS__",
            "name": "__RICOR_REGS__",
            "optional": true,
            "type": "String",
            "value-key": "__RICOR_REGS__"
        },
        {
            "command-line-flag": "-regress_apply_mot_types",
            "description": "-regress_apply_mot_types demean deriv   \\",
            "id": "__REGRESS_APPLY_MOT_TYPES__",
            "name": "__REGRESS_APPLY_MOT_TYPES__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_APPLY_MOT_TYPES__"
        },
        {
            "command-line-flag": "-regress_run_clustsim",
            "description": "-regress_run_clustsim no                \\ -regress_est_blur_epits                 \\ -regress_est_blur_errts  Example 6. A modern example.  GOOD TO CONSIDER. ~2~  Align the EPI to the anatomy.  Also, process in MNI space, using the 2009c non-linear template.  For alignment in either direction, add the 'align' block, which aligns the anatomy to the EPI.  To then align the EPI to the anat using the lpc+ZZ cost function (instead of just lpc), apply -volreg_align_e2a, where that transform (inverse) is applied along with the motion alignment.  On top of that, complete the processing in standard space by running @auto_tlrc on the anat (via the 'tlrc' block) and applying the same transformation to the EPI via -volreg_tlrc_warp.  Again, the EPI transformation is applied along with the motion alignment, using the volume with the minimum outlier fraction as the alignment base (option '-volreg_align_to MIN_OUTLIER').  So use the given -blocks option, plus 2 extra volreg warps to #3 via '-volreg_align_e2a', '-volreg_tlrc_warp'.  As an added bonus, censor TR pairs where the Euclidean Norm of the motion derivative exceeds 0.3.  Also, regress motion parameters separately for each run.  afni_proc.py -subj_id sb23.e6.align                        \\ -copy_anat sb23/sb23_mpra+orig                     \\",
            "id": "__REGRESS_RUN_CLUSTSIM__",
            "name": "__REGRESS_RUN_CLUSTSIM__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_RUN_CLUSTSIM__"
        },
        {
            "command-line-flag": "-align_opts_aea",
            "description": "-align_opts_aea -cost lpc+ZZ                       \\ -tlrc_base MNI152_T1_2009c+tlrc                    \\ -volreg_align_to MIN_OUTLIER                       \\ -volreg_align_e2a                                  \\ -volreg_tlrc_warp                                  \\",
            "id": "__ALIGN_OPTS_AEA__",
            "name": "__ALIGN_OPTS_AEA__",
            "optional": true,
            "type": "String",
            "value-key": "__ALIGN_OPTS_AEA__"
        },
        {
            "command-line-flag": "-regress_stim_types",
            "description": "-regress_stim_types times times times              \\ AM2   AM2   AM2                \\ times times times              \\",
            "id": "__REGRESS_STIM_TYPES__",
            "name": "__REGRESS_STIM_TYPES__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_STIM_TYPES__"
        },
        {
            "command-line-flag": "-regress_basis_multi",
            "description": "-regress_basis_multi                               \\ 'BLOCK(30,1)' 'TENT(0,45,16)' 'BLOCK(30,1)'     \\ 'BLOCK(30,1)' 'TENT(0,45,16)' 'BLOCK(30,1)'     \\ 'BLOCK(30,1)' 'TENT(0,45,16)' 'BLOCK(30,1)'     \\",
            "id": "__REGRESS_BASIS_MULTI__",
            "name": "__REGRESS_BASIS_MULTI__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_BASIS_MULTI__"
        },
        {
            "command-line-flag": "-blocks",
            "description": "includes surf, but no mask (default blocks for surf, so not needed)",
            "id": "__BLOCKS__",
            "name": "__BLOCKS__",
            "optional": true,
            "type": "String",
            "value-key": "__BLOCKS__"
        },
        {
            "command-line-flag": "-surf_anat",
            "description": "volume aligned with surface",
            "id": "__SURF_ANAT__",
            "name": "__SURF_ANAT__",
            "optional": true,
            "type": "String",
            "value-key": "__SURF_ANAT__"
        },
        {
            "command-line-flag": "-surf_spec",
            "description": "spec file(s) for surface  Note: one would probably want to use standard mesh surfaces here. This example will be updated with them in the future.  afni_proc.py -subj_id FT.surf                            \\ -blocks tshift align volreg surf blur scale regress  \\ -copy_anat FT/FT_anat+orig                           \\",
            "id": "__SURF_SPEC__",
            "name": "__SURF_SPEC__",
            "optional": true,
            "type": "String",
            "value-key": "__SURF_SPEC__"
        },
        {
            "command-line-flag": "-mask_segment_erode",
            "description": "-mask_segment_erode.  afni_proc.py -subj_id subj123                                \\",
            "id": "__MASK_SEGMENT_ERODE__",
            "name": "__MASK_SEGMENT_ERODE__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_SEGMENT_ERODE__"
        },
        {
            "command-line-flag": "-mask_segment_anat",
            "description": "-mask_segment_anat and -mask_segment_erode options.  ** While -mask_segment_anat also creates a CSF mask, that mask is ALL CSF, not just restricted to the ventricles, for example.  So it is probably not appropriate for use in tissue-based regression.  CSFe was previously used as an example of what one could do, but as it is not advised, it has been removed.  Also, align to minimum outlier volume, and align to the anatomy using cost function lpc+ZZ.  Note: it might be reasonable to estimate the blur using epits rather than errts in the case of bandpassing.  Both options are included here.  afni_proc.py -subj_id subj123                                \\",
            "id": "__MASK_SEGMENT_ANAT__",
            "name": "__MASK_SEGMENT_ANAT__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_SEGMENT_ANAT__"
        },
        {
            "command-line-flag": "-regress_ROI",
            "description": "-regress_ROI WMe                                           \\ -regress_est_blur_epits                                    \\ -regress_est_blur_errts  Example 10b. Resting state analysis, as 10a with 3dRSFC. ~2~  This is for band passing and computation of ALFF, etc.  * This will soon use a modified 3dRSFC.  Like example #10, but add -regress_RSFC to bandpass via 3dRSFC. Skip censoring and regression band passing because of the bandpass operation in 3dRSFC.  To correspond to common tractography, this example stays in orig space (no 'tlrc' block, no -volreg_tlrc_warp option).  Of course, going to standard space is an option.  afni_proc.py -subj_id subj123                                \\",
            "id": "__REGRESS_ROI__",
            "name": "__REGRESS_ROI__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_ROI__"
        },
        {
            "command-line-flag": "-anat_follower_erode",
            "description": "-anat_follower_erode FSvent FSWe                           \\",
            "id": "__ANAT_FOLLOWER_ERODE__",
            "name": "__ANAT_FOLLOWER_ERODE__",
            "optional": true,
            "type": "String",
            "value-key": "__ANAT_FOLLOWER_ERODE__"
        },
        {
            "command-line-flag": "-regress_make_corr_vols",
            "description": "-regress_make_corr_vols aeseg FSvent                       \\ -regress_anaticor_fast                                     \\ -regress_anaticor_label FSWe                               \\ -regress_censor_motion 0.2                                 \\ -regress_censor_outliers 0.1                               \\",
            "id": "__REGRESS_MAKE_CORR_VOLS__",
            "name": "__REGRESS_MAKE_CORR_VOLS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_MAKE_CORR_VOLS__"
        },
        {
            "command-line-flag": "-e",
            "description": "-expr 'amongst(a,152,170)' -prefix template_ventricle 3dresample -dxyz 2.5 2.5 2.5 -inset template_ventricle+tlrc \\ -prefix template_ventricle_2.5mm  o Be explicit with 2.5mm, using '-volreg_warp_dxyz 2.5'. o Use template TT_N27+tlrc, to be aligned with the desai atlas. o No -anat_follower options, but use -mask_import to import the template_ventricle_2.5mm dataset (and call it Tvent). o Use -mask_intersect to intersect ventricle mask with the subject's CSFe mask, making a more reliable subject ventricle mask (Svent). o Ventricle principle components are created as per-run regressors. o Make WMe and Svent correlation volumes, which are just for entertainment purposes anyway. o Run the cluster simulation.  afni_proc.py -subj_id FT.11b.rest                            \\ -blocks despike tshift align tlrc volreg blur mask regress \\ -copy_anat FT_anat+orig                                    \\",
            "id": "__E__",
            "name": "__E__",
            "optional": true,
            "type": "String",
            "value-key": "__E__"
        },
        {
            "command-line-flag": "-regress_ROI_PC_per_run",
            "description": "-regress_ROI_PC_per_run Svent                              \\",
            "id": "__REGRESS_ROI_PC_PER_RUN__",
            "name": "__REGRESS_ROI_PC_PER_RUN__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_ROI_PC_PER_RUN__"
        },
        {
            "command-line-flag": "-dsets_me_echo",
            "description": "specify ME data, per echo",
            "id": "__DSETS_ME_ECHO__",
            "name": "__DSETS_ME_ECHO__",
            "optional": true,
            "type": "String",
            "value-key": "__DSETS_ME_ECHO__"
        },
        {
            "command-line-flag": "-dsets_me_run",
            "description": "specify ME data, per run (alternative to _echo)",
            "id": "__DSETS_ME_RUN__",
            "name": "__DSETS_ME_RUN__",
            "optional": true,
            "type": "String",
            "value-key": "__DSETS_ME_RUN__"
        },
        {
            "command-line-flag": "-echo_times",
            "description": "specify echo times (if needed)",
            "id": "__ECHO_TIMES__",
            "name": "__ECHO_TIMES__",
            "optional": true,
            "type": "String",
            "value-key": "__ECHO_TIMES__"
        },
        {
            "command-line-flag": "-combine_method",
            "description": "specify method to combine echoes (if any)  An afni_proc.py command might be updated to include something like:  afni_proc.py ...                                     \\ -blocks tshift align tlrc volreg mask combine    \\ blur scale regress                       \\",
            "id": "__COMBINE_METHOD__",
            "name": "__COMBINE_METHOD__",
            "optional": true,
            "type": "String",
            "value-key": "__COMBINE_METHOD__"
        },
        {
            "command-line-flag": "-mask_epi_anat",
            "description": "-mask_epi_anat yes                               \\ -combine_method OC                               \\ ...                                              \\   Example 12a. Multi-echo data processing - very simple. ~2~  Keep it simple and just focus on the basic ME options, plus a few for controlling registration.  o This example uses 3 echoes of data across just 1 run. - so use a single -dsets_me_run option to input EPI datasets o Echo 2 is used to drive registration for all echoes. - That is the default, but it is good to be explicit. o The echo times are not needed, as the echoes are never combined. o The echo are never combined (in this example), so that there are always 3 echoes, even until the end. - Note that the 'regress' block is not valid for multiple echoes.  afni_proc.py -subj_id FT.12a.ME                 \\ -blocks tshift align tlrc volreg mask blur    \\ -copy_anat FT_anat+orig                       \\",
            "id": "__MASK_EPI_ANAT__",
            "name": "__MASK_EPI_ANAT__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_EPI_ANAT__"
        },
        {
            "command-line-flag": "-blur_in_mask",
            "description": "-blur_in_mask yes                             \\ -regress_motion_per_run                       \\ -regress_censor_motion 0.2                    \\ -regress_censor_outliers 0.1                  \\",
            "id": "__BLUR_IN_MASK__",
            "name": "__BLUR_IN_MASK__",
            "optional": true,
            "type": "String",
            "value-key": "__BLUR_IN_MASK__"
        },
        {
            "command-line-flag": "-ask_me",
            "description": "** NOTE: -ask_me is antiquated ** ~2~  a1. Apply -ask_me in the most basic form, with no other options.  afni_proc.py -ask_me  a2. Supply input datasets.  afni_proc.py -ask_me -dsets ED/ED_r*.HEAD  a3. Same as a2, but supply the datasets in expanded form. No suffix (.HEAD) is needed when wildcards are not used.  afni_proc.py -ask_me                          \\",
            "id": "__ASK_ME__",
            "name": "__ASK_ME__",
            "optional": true,
            "type": "String",
            "value-key": "__ASK_ME__"
        },
        {
            "command-line-flag": "-giant_move",
            "description": "-giant_move option may be necessary independently.  Examples of some helpful options:",
            "id": "__GIANT_MOVE__",
            "name": "__GIANT_MOVE__",
            "optional": true,
            "type": "String",
            "value-key": "__GIANT_MOVE__"
        },
        {
            "command-line-flag": "-help",
            "description": "show this help",
            "id": "__HELP__",
            "name": "__HELP__",
            "optional": true,
            "type": "String",
            "value-key": "__HELP__"
        },
        {
            "command-line-flag": "-hist",
            "description": "show the module history",
            "id": "__HIST__",
            "name": "__HIST__",
            "optional": true,
            "type": "String",
            "value-key": "__HIST__"
        },
        {
            "command-line-flag": "-requires_afni_version",
            "description": "show AFNI date required by processing script  Many updates to afni_proc.py are accompanied by corresponding updates to other AFNI programs.  So if the processing script is created on one computer but executed on another (with an older version of AFNI), confusing failures could result.  The required date is adjusted whenever updates are made that rely on new features of some other program.  If the processing script checks the AFNI version, the AFNI package must be as current as the date output via this option.  Checks are controlled by the option '-check_afni_version'.  The checking method compares the output of: afni_proc.py -requires_afni_version  against the most recent date in afni_history: afni_history -past_entries 1  See also '-requires_afni_hist'.  See also '-check_afni_version'.",
            "id": "__REQUIRES_AFNI_VERSION__",
            "name": "__REQUIRES_AFNI_VERSION__",
            "optional": true,
            "type": "String",
            "value-key": "__REQUIRES_AFNI_VERSION__"
        },
        {
            "command-line-flag": "-requires_afni_hist",
            "description": "show history of -requires_afni_version  List the history of '-requires_afni_version' dates and reasons.",
            "id": "__REQUIRES_AFNI_HIST__",
            "name": "__REQUIRES_AFNI_HIST__",
            "optional": true,
            "type": "String",
            "value-key": "__REQUIRES_AFNI_HIST__"
        },
        {
            "command-line-flag": "-show_valid_opts",
            "description": "show all valid options (brief format)",
            "id": "__SHOW_VALID_OPTS__",
            "name": "__SHOW_VALID_OPTS__",
            "optional": true,
            "type": "String",
            "value-key": "__SHOW_VALID_OPTS__"
        },
        {
            "command-line-flag": "-ver",
            "description": "show the version number  ----------------------------------------------------------------- General execution and setup options ~3~",
            "id": "__VER__",
            "name": "__VER__",
            "optional": true,
            "type": "String",
            "value-key": "__VER__"
        },
        {
            "command-line-flag": "-anat_follower",
            "description": "specify anat follower dataset  e.g. -anat_follower GM anat FS_GM_MASK.nii  Use this option to pass any anatomical follower dataset.  Such a dataset is warped by any transformations that take the original anat to anat_final.  Anatomical follower datasets are resampled using wsinc5.  The only difference with -anat_follower_ROI is that such ROI datasets are resampled using nearest neighbor interpolation.  LABEL    : to name and refer to this dataset GRID     : which grid should this be sampled on, anat or epi? DSET     : name of input dataset, changed to copy_af_LABEL  A default anatomical follower (in the case of skull stripping) is the original anat.  That is to get a warped version that still has a skull, for quality control.  See also -anat_follower_ROI, anat_follower_erode.",
            "id": "__ANAT_FOLLOWER__",
            "name": "__ANAT_FOLLOWER__",
            "optional": true,
            "type": "String",
            "value-key": "__ANAT_FOLLOWER__"
        },
        {
            "command-line-flag": "-anat_follower_ROI",
            "description": "specify anat follower ROI dataset  e.g. -anat_follower_ROI aaseg anat aparc.a2009s+aseg.nii e.g. -anat_follower_ROI FSvent epi FreeSurfer_ventricles.nii  Use this option to pass any anatomical follower dataset.  Such a dataset is warped by any transformations that take the original anat to anat_final.  Similar to -anat_follower, except that these anatomical follower datasets are resampled using nearest neighbor (NN) interpolation, to preserve data values (as opposed to -anat_follower, which uses wsinc5).  That is the only difference between these options.  LABEL    : to name and refer to this dataset GRID     : which grid should this be sampled on, anat or epi? DSET     : name of input dataset, changed to copy_af_LABEL  Labels defined via this option may be used in -regress_ROI or _PC.  See also -anat_follower, anat_follower_erode, -regress_ROI or -regress_ROI_PC.",
            "id": "__ANAT_FOLLOWER_ROI__",
            "name": "__ANAT_FOLLOWER_ROI__",
            "optional": true,
            "type": "String",
            "value-key": "__ANAT_FOLLOWER_ROI__"
        },
        {
            "command-line-flag": "-anat_has_skull",
            "description": "-anat_has_skull yes/no  : specify whether the anatomy has a skull  e.g. -anat_has_skull no  Use this option to block any skull-stripping operations, likely either in the align or tlrc processing blocks.",
            "id": "__ANAT_HAS_SKULL__",
            "name": "__ANAT_HAS_SKULL__",
            "optional": true,
            "type": "String",
            "value-key": "__ANAT_HAS_SKULL__"
        },
        {
            "command-line-flag": "-anat_uniform_method",
            "description": "specify uniformity correction method  e.g. -anat_uniform_method unifize  Specify the method for anatomical intensity uniformity correction.  none    : do not do uniformity correction at all default : use 3dUnifize at whim of auto_warp.py unifize : apply 3dUnifize early in processing stream (so it affects more than auto_warp.py)  Please see '3dUnifize -help' for details. See also -anat_opts_unif.",
            "id": "__ANAT_UNIFORM_METHOD__",
            "name": "__ANAT_UNIFORM_METHOD__",
            "optional": true,
            "type": "String",
            "value-key": "__ANAT_UNIFORM_METHOD__"
        },
        {
            "command-line-flag": "-anat_opts_unif",
            "description": "-anat_opts_unif OPTS ... : specify extra options for unifize command  e.g. -anat_opts_unif -Urad 14  Specify options to be applied to the command used for anatomical intensity uniformity correction, such as 3dUnifize.  Please see '3dUnifize -help' for details. See also -anat_uniform_method.",
            "id": "__ANAT_OPTS_UNIF__",
            "name": "__ANAT_OPTS_UNIF__",
            "optional": true,
            "type": "String",
            "value-key": "__ANAT_OPTS_UNIF__"
        },
        {
            "command-line-flag": "-anat_unif_GM",
            "description": "-anat_unif_GM yes/no    : also unifize gray matter (lower intensities) the default is 'no'  e.g. -anat_unif_GM yes default: -anat_unif_GM no  If this is set to yes, 3dUnifize will not only apply uniformity correction across the brain volume, but also to voxels that look like gray matter.  That is to say the option adds '-GM' to the 3dUnifize command.  * The default was changed from yes to no 2014, May 16.  Please see '3dUnifize -help' for details. See also -anat_uniform_method, -anat_opts_unif.",
            "id": "__ANAT_UNIF_GM__",
            "name": "__ANAT_UNIF_GM__",
            "optional": true,
            "type": "String",
            "value-key": "__ANAT_UNIF_GM__"
        },
        {
            "command-line-flag": "-bash",
            "description": "show example execution command in bash form  After the script file is created, this program suggests how to run it (piping stdout/stderr through 'tee').  If the user is running the bash shell, this option will suggest the 'bash' form of a command to execute the newly created script.  example of tcsh form for execution:  tcsh -x proc.ED.8.glt |& tee output.proc.ED.8.glt  example of bash form for execution:  tcsh -x proc.ED.8.glt 2>&1 | tee output.proc.ED.8.glt  Please see \"man bash\" or \"man tee\" for more information.  -blocks BLOCK1 ...      : specify the processing blocks to apply  e.g. -blocks volreg blur scale regress e.g. -blocks despike tshift align volreg blur scale regress default: tshift volreg blur mask scale regress  The user may apply this option to specify which processing blocks are to be included in the output script.  The order of the blocks may be varied, and blocks may be skipped.  See also '-do_block' (e.g. '-do_block despike').",
            "id": "__BASH__",
            "name": "__BASH__",
            "optional": true,
            "type": "String",
            "value-key": "__BASH__"
        },
        {
            "command-line-flag": "-check_afni_version",
            "description": "-check_afni_version yes/no : check that AFNI is current enough  e.g. -check_afni_version no default: yes  Check that the version of AFNI is recent enough for processing of the afni_proc.py script.  For the version check, the output of: afni_proc.py -requires_afni_version  is tested against the most recent date in afni_history: afni_history -past_entries 1  In the case that newer features in other programs might not be needed by the given afni_proc.py script (depending on the options), the user is left with this option to ignore the AFNI version check.  Please see 'afni_history -help' or 'afni -ver' for more information. See also '-requires_afni_version'.",
            "id": "__CHECK_AFNI_VERSION__",
            "name": "__CHECK_AFNI_VERSION__",
            "optional": true,
            "type": "String",
            "value-key": "__CHECK_AFNI_VERSION__"
        },
        {
            "command-line-flag": "-check_results_dir",
            "description": "-check_results_dir yes/no : check whether dir exists before proceeding  e.g. -check_results_dir no default: yes  By default, if the results directory already exists, the script will terminate before doing any processing.  Set this option to 'no' to remove that check.",
            "id": "__CHECK_RESULTS_DIR__",
            "name": "__CHECK_RESULTS_DIR__",
            "optional": true,
            "type": "String",
            "value-key": "__CHECK_RESULTS_DIR__"
        },
        {
            "command-line-flag": "-check_setup_errors",
            "description": "-check_setup_errors yes/no : terminate on setup errors  e.g. -check_setup_errors yes default: no  Have the script check $status after each command in the setup processing block.  It is preferable to run the script using the",
            "id": "__CHECK_SETUP_ERRORS__",
            "name": "__CHECK_SETUP_ERRORS__",
            "optional": true,
            "type": "String",
            "value-key": "__CHECK_SETUP_ERRORS__"
        },
        {
            "command-line-flag": "-copy_anat",
            "description": "copy the ANAT dataset to the results dir  e.g. -copy_anat Elvis/mprage+orig  This will apply 3dcopy to copy the anatomical dataset(s) to the results directory.  Note that if a +view is not given, 3dcopy will attempt to copy +acpc and +tlrc datasets, also.  See also '3dcopy -help'.",
            "id": "__COPY_ANAT__",
            "name": "__COPY_ANAT__",
            "optional": true,
            "type": "String",
            "value-key": "__COPY_ANAT__"
        },
        {
            "command-line-flag": "-copy_files",
            "description": "-copy_files file1 ...   : copy file1, etc. into the results directory  e.g. -copy_files glt_AvsB.txt glt_BvsC.1D glt_eat_cheese.txt e.g. -copy_files contrasts/glt_*.txt  This option allows the user to copy some list of files into the results directory.  This would happen before the tcat block, so such files may be used for other commands in the script (such as contrast files in 3dDeconvolve, via -regress_opts_3dD).",
            "id": "__COPY_FILES__",
            "name": "__COPY_FILES__",
            "optional": true,
            "type": "String",
            "value-key": "__COPY_FILES__"
        },
        {
            "command-line-flag": "-execute",
            "description": "execute the created processing script  If this option is applied, not only will the processing script be created, but it will then be executed in the \"suggested\" manner, such as via:  tcsh -xef proc.sb23 |& tee output.proc.sb23  Note that it will actually use the bash format of the command, since the system command (C and therefore python) uses /bin/sh.  tcsh -xef proc.sb23 2>&1 | tee output.proc.sb23",
            "id": "__EXECUTE__",
            "name": "__EXECUTE__",
            "optional": true,
            "type": "String",
            "value-key": "__EXECUTE__"
        },
        {
            "command-line-flag": "-gen_epi_review",
            "description": "specify script for EPI review  e.g. -gen_epi_review review_orig_EPI.txt  By default, the proc script calls gen_epi_review.py on the original EPI data (from the tcat step, so only missing pre-SS TRs).  This creates a \"drive afni\" script that the user can run to quickly scan that EPI data for apparent issues.  Without this option, the script will be called @epi_review.$subj, where $subj is the subject ID.  The script starts afni, loads the first EPI run and starts scanning through time (effectively hitting 'v' in the graph window).  The user can press <enter> in the prompting terminal window to go to each successive run.  Note that the user has full control over afni, aside from a new run being loaded whey they hit <enter>.  Recall that the <space> key (applied in the graph window) can terminate the 'v' (video mode).  See 'gen_epi_review.py -help' for details. See also 'no_epi_review', to disable this feature.",
            "id": "__GEN_EPI_REVIEW__",
            "name": "__GEN_EPI_REVIEW__",
            "optional": true,
            "type": "String",
            "value-key": "__GEN_EPI_REVIEW__"
        },
        {
            "command-line-flag": "-no_epi_review",
            "description": "-no_epi_review  This option is used to prevent writing a gen_epi_review.py command in the processing script (i.e. do not create a script to review the EPI data).  The only clear reason to want this option is if gen_epi_review.py fails for some reason.  It should not hurt to create that little text file (@epi_review.$subj, by default).  See also '-gen_epi_review'.",
            "id": "__NO_EPI_REVIEW__",
            "name": "__NO_EPI_REVIEW__",
            "optional": true,
            "type": "String",
            "value-key": "__NO_EPI_REVIEW__"
        },
        {
            "command-line-flag": "-keep_rm_files",
            "description": "do not have script delete rm.* files at end  e.g. -keep_rm_files  The output script may generate temporary files in a block, which would be given names with prefix 'rm.'.  By default, those files are deleted at the end of the script.  This option blocks that deletion.",
            "id": "__KEEP_RM_FILES__",
            "name": "__KEEP_RM_FILES__",
            "optional": true,
            "type": "String",
            "value-key": "__KEEP_RM_FILES__"
        },
        {
            "command-line-flag": "-move_preproc_files",
            "description": "move preprocessing files to preproc.data dir  At the end of the output script, create a 'preproc.data' directory, and move most of the files there (dfile, outcount, pb*, rm*).  See also -remove_preproc_files.",
            "id": "__MOVE_PREPROC_FILES__",
            "name": "__MOVE_PREPROC_FILES__",
            "optional": true,
            "type": "String",
            "value-key": "__MOVE_PREPROC_FILES__"
        },
        {
            "command-line-flag": "-no_proc_command",
            "description": "do not print afni_proc.py command in script  e.g. -no_proc_command  If this option is applied, the command used to generate the output script will be stored at the end of the script.",
            "id": "__NO_PROC_COMMAND__",
            "name": "__NO_PROC_COMMAND__",
            "optional": true,
            "type": "String",
            "value-key": "__NO_PROC_COMMAND__"
        },
        {
            "command-line-flag": "-out_dir",
            "description": "specify the output directory for the script  e.g. -out_dir ED_results default: SUBJ.results  The AFNI processing script will create this directory and perform all processing in it.",
            "id": "__OUT_DIR__",
            "name": "__OUT_DIR__",
            "optional": true,
            "type": "String",
            "value-key": "__OUT_DIR__"
        },
        {
            "command-line-flag": "-outlier_count",
            "description": "-outlier_count yes/no   : should we count outliers with 3dToutcount?  e.g. -outlier_count no default: yes  By default, outlier fractions are computed per TR with 3dToutcount. To disable outlier counting, apply this option with parameter 'no'. This is a yes/no option, meaning those are the only valid inputs.  Note that -outlier_count must be 'yes' in order to censor outliers with -regress_censor_outliers.  See \"3dToutcount -help\" for more details. See also -regress_censor_outliers.",
            "id": "__OUTLIER_COUNT__",
            "name": "__OUTLIER_COUNT__",
            "optional": true,
            "type": "String",
            "value-key": "__OUTLIER_COUNT__"
        },
        {
            "command-line-flag": "-outlier_legendre",
            "description": "-outlier_legendre yes/no : use Legendre polynomials in 3dToutcount?  e.g. -outlier_legendre no default: yes  By default the -legendre option is passed to 3dToutcount.  Along with using better behaved polynomials, it also allows them to be higher than 3rd order (if desired).  See \"3dToutcount -help\" for more details.",
            "id": "__OUTLIER_LEGENDRE__",
            "name": "__OUTLIER_LEGENDRE__",
            "optional": true,
            "type": "String",
            "value-key": "__OUTLIER_LEGENDRE__"
        },
        {
            "command-line-flag": "-outlier_polort",
            "description": "specify polynomial baseline for 3dToutcount  e.g. -outlier_polort 3 default: same degree that 3dDeconvolve would use: 1 + floor(run_length/150)  Outlier counts come after detrending the data, where the degree of the polynomial trend defaults to the same that 3dDeconvolve would use.  This option will override the default.  See \"3dToutcount -help\" for more details. See \"3dDeconvolve -help\" for more details. See also '-regress_polort' and '-outlier_legendre'.",
            "id": "__OUTLIER_POLORT__",
            "name": "__OUTLIER_POLORT__",
            "optional": true,
            "type": "String",
            "value-key": "__OUTLIER_POLORT__"
        },
        {
            "command-line-flag": "-radial_correlate",
            "description": "-radial_correlate yes/no : correlate each voxel with local radius  e.g. -radial_correlate yes default: no  With this option set, @radial_correlate will be run on the initial EPI time series datasets.  That creates a 'corr_test' directory that one can review, plus potential warnings (in text) if large clusters of high correlations are found.  (very abbreviated) method for @radial_correlate: for each voxel compute average time series within 20 mm radius sphere correlate central voxel time series with spherical average look for clusters of high correlations  This is a useful quality control (QC) dataset that helps one find scanner artifacts, particularly including coils going bad.  To visually check the results, the program text output suggests:  run command: afni corr_test.results.postdata then set:    Underlay  = epi.SOMETHING Overlay   = res.SOMETHING.corr maybe threshold = 0.9, maybe clusterize  See \"@radial_correlate -help\" for details and a list of options.",
            "id": "__RADIAL_CORRELATE__",
            "name": "__RADIAL_CORRELATE__",
            "optional": true,
            "type": "String",
            "value-key": "__RADIAL_CORRELATE__"
        },
        {
            "command-line-flag": "-reg_echo",
            "description": "specify 1-based echo for registration  e.g. -reg_echo 3 default: 2  Multi-echo data is registered based on a single echo, with the resulting transformations being applied to all echoes.  Use this option to specify the 1-based echo used to drive registration.  Note that the echo used for driving registration should have reasonable tissue contrast.",
            "id": "__REG_ECHO__",
            "name": "__REG_ECHO__",
            "optional": true,
            "type": "String",
            "value-key": "__REG_ECHO__"
        },
        {
            "command-line-flag": "-remove_preproc_files",
            "description": "delete pre-processed data  At the end of the output script, delete the intermediate data (to save disk space).  Delete dfile*, outcount*, pb* and rm*.  See also -move_preproc_files.",
            "id": "__REMOVE_PREPROC_FILES__",
            "name": "__REMOVE_PREPROC_FILES__",
            "optional": true,
            "type": "String",
            "value-key": "__REMOVE_PREPROC_FILES__"
        },
        {
            "command-line-flag": "-script",
            "description": "specify the name of the resulting script  e.g. -script ED.process.script default: proc_subj  The output of this program is a script file.  This option can be used to specify the name of that file.  See also -scr_overwrite, -subj_id.",
            "id": "__SCRIPT__",
            "name": "__SCRIPT__",
            "optional": true,
            "type": "String",
            "value-key": "__SCRIPT__"
        },
        {
            "command-line-flag": "-scr_overwrite",
            "description": "overwrite any existing script  e.g. -scr_overwrite  If the output script file already exists, it will be overwritten only if the user applies this option.  See also -script.",
            "id": "__SCR_OVERWRITE__",
            "name": "__SCR_OVERWRITE__",
            "optional": true,
            "type": "String",
            "value-key": "__SCR_OVERWRITE__"
        },
        {
            "command-line-flag": "-sep_char",
            "description": "apply as separation character in filenames  e.g. -sep_char _ default: .  The separation character is used in many output filenames, such as the default '.' in:  pb04.Nancy.r07.scale+orig.BRIK  If (for some crazy reason) an underscore (_) character would be preferable, the result would be:  pb04_Nancy_r07_scale+orig.BRIK  If \"-sep_char _\" is applied, so is -subj_curly.  See also -subj_curly.",
            "id": "__SEP_CHAR__",
            "name": "__SEP_CHAR__",
            "optional": true,
            "type": "String",
            "value-key": "__SEP_CHAR__"
        },
        {
            "command-line-flag": "-subj_curly",
            "description": "apply $subj as ${subj}  The subject ID is used in dataset names is typically used without curly brackets (i.e. $subj).  If something is done where this would result in errors (e.g. \"-sep_char _\"), the curly brackets might be useful to delimit the variable (i.e. ${subj}).  Note that this option is automatically applied in the case of \"-sep_char _\".  See also -sep_char.",
            "id": "__SUBJ_CURLY__",
            "name": "__SUBJ_CURLY__",
            "optional": true,
            "type": "String",
            "value-key": "__SUBJ_CURLY__"
        },
        {
            "command-line-flag": "-subj_id",
            "description": "specify the subject ID for the script  e.g. -subj_id elvis default: SUBJ  The subject ID is used in dataset names and in the output directory name (unless -out_dir is used).  This option allows the user to apply an appropriate naming convention.",
            "id": "__SUBJ_ID__",
            "name": "__SUBJ_ID__",
            "optional": true,
            "type": "String",
            "value-key": "__SUBJ_ID__"
        },
        {
            "command-line-flag": "-test_for_dsets",
            "description": "-test_for_dsets yes/no  : test for existence of input datasets  e.g. -test_for_dsets no default: yes  This options controls whether afni_proc.py check for the existence of input datasets.  In general, they must exist when afni_proc.py is run, in order to get run information (TR, #TRs, #runs, etc).",
            "id": "__TEST_FOR_DSETS__",
            "name": "__TEST_FOR_DSETS__",
            "optional": true,
            "type": "String",
            "value-key": "__TEST_FOR_DSETS__"
        },
        {
            "command-line-flag": "-test_stim_files",
            "description": "-test_stim_files yes/no : evaluate stim_files for appropriateness?  e.g. -test_stim_files no default: yes  This options controls whether afni_proc.py evaluates the stim_files for validity.  By default, the program will do so.  Input files are one of local stim_times, global stim_times or 1D formats.  Options -regress_stim_files and -regress_extra_stim_files imply 1D format for input files.  Otherwise, -regress_stim_times is assumed to imply local stim_times format (-regress_global_times implies global stim_times format).  Checks include:  1D              : # rows equals total reps local times     : # rows equal # runs : times must be >= 0.0 : times per run (per row) are unique : times cannot exceed run time global times    : file must be either 1 row or 1 column : times must be >= 0.0 : times must be unique : times cannot exceed total duration of all runs  This option provides the ability to disable this test.  See \"1d_tool.py -help\" for details on '-look_like_*' options. See also -regress_stim_files, -regress_extra_stim_files,",
            "id": "__TEST_STIM_FILES__",
            "name": "__TEST_STIM_FILES__",
            "optional": true,
            "type": "String",
            "value-key": "__TEST_STIM_FILES__"
        },
        {
            "command-line-flag": "-verb",
            "description": "specify the verbosity of this script  e.g. -verb 2 default: 1  Print out extra information during execution.",
            "id": "__VERB__",
            "name": "__VERB__",
            "optional": true,
            "type": "String",
            "value-key": "__VERB__"
        },
        {
            "command-line-flag": "-write_3dD_prefix",
            "description": "specify prefix for outputs from 3dd_script  e.g. -write_3dD_prefix basis.tent. default: test.  If a separate 3dDeconvolve command script is generated via the option -write_3dD_script, then the given PREFIX will be used for relevant output files. in the script.  See also -write_3dD_script.",
            "id": "__WRITE_3DD_PREFIX__",
            "name": "__WRITE_3DD_PREFIX__",
            "optional": true,
            "type": "String",
            "value-key": "__WRITE_3DD_PREFIX__"
        },
        {
            "command-line-flag": "-write_3dD_script",
            "description": "specify SCRIPT only for 3dDeconvolve command  e.g. -write_3dD_script run.3dd.tent  This option is intended to be used with the EXACT same afni_proc.py command (aside from any -write_3dD_* options).  The purpose is to generate a corresponding 3dDeconvolve command script which could be run in the same results directory.  Alternatively, little things could be changed that would only affect the 3dDeconvolve command in the new script, such as the basis function(s).  The new script should include a prefix to distinguish output files from those created by the original proc script.  * This option implies '-test_stim_files no'.  See also -write_3dD_prefix, -test_stim_files.",
            "id": "__WRITE_3DD_SCRIPT__",
            "name": "__WRITE_3DD_SCRIPT__",
            "optional": true,
            "type": "String",
            "value-key": "__WRITE_3DD_SCRIPT__"
        },
        {
            "command-line-flag": "-write_ppi_3dD_scripts",
            "description": "flag: write 3dD scripts for PPI analysis  e.g. -write_ppi_3dD_scripts                        \\",
            "id": "__WRITE_PPI_3DD_SCRIPTS__",
            "name": "__WRITE_PPI_3DD_SCRIPTS__",
            "optional": true,
            "type": "String",
            "value-key": "__WRITE_PPI_3DD_SCRIPTS__"
        },
        {
            "command-line-flag": "-regress_ppi_stim_files",
            "description": "-regress_ppi_stim_files PPI_*.1D some_seed.1D \\",
            "id": "__REGRESS_PPI_STIM_FILES__",
            "name": "__REGRESS_PPI_STIM_FILES__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_PPI_STIM_FILES__"
        },
        {
            "command-line-flag": "-regress_ppi_stim_labels",
            "description": "-regress_ppi_stim_labels PPI_A PPI_B PPI_C seed  Request 3dDeconvolve scripts for pre-PPI filtering (do regression without censoring) and post-PPI filtering (include PPI regressors and seed).  This is a convenience method for creating extra 3dDeconvolve command scripts without having to run afni_proc.py multiple times with different options.  Using this option, afni_proc.py will create the main proc script, plus :  A. (if censoring was done) an uncensored 3dDeconvolve command pre-PPI filter script, to create an uncensored errts time series.  This script is akin to using -write_3dD_* to output a regression script, along with adding -regress_skip_censor. The regression command should be identical to the original one, except for inclusion of 3dDeconvolve's -censor option.  B. a 3dDeconvolve post-PPI filter script to include the PPI and seed regressors.  This script is akin to using -write_3dD_* to output a regression script, along with passing the PPI and seed regressors via -regress_extra_stim_files and _labels.  Use -regress_ppi_stim_files and -regress_ppi_stim_labels to specify the PPI (and seed) regressors and their labels.  These options are currently required.  See also -regress_ppi_stim_files, -regress_ppi_stim_labels.  ----------------------------------------------------------------- Block options (in default block order) ~3~  These options pertain to individual processing blocks.  Each option starts with the block name.",
            "id": "__REGRESS_PPI_STIM_LABELS__",
            "name": "__REGRESS_PPI_STIM_LABELS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_PPI_STIM_LABELS__"
        },
        {
            "command-line-flag": "-tcat_preSS_warn_limit",
            "description": "TR #0 outlier limit to warn of pre-SS  e.g. -tcat_preSS_warn_limit 0.7 default: 0.4  Outlier fractions are computed across TRs in the tcat processing block.  If TR #0 has a large fraction, it might suggest that pre- steady state TRs have been included in the analysis.  If the detected fraction exceeds this limit, a warning will be stored (and output by the @ss_review_basic script).  The special case of limit = 0.0 implies no check will be done.",
            "id": "__TCAT_PRESS_WARN_LIMIT__",
            "name": "__TCAT_PRESS_WARN_LIMIT__",
            "optional": true,
            "type": "String",
            "value-key": "__TCAT_PRESS_WARN_LIMIT__"
        },
        {
            "command-line-flag": "-tcat_remove_first_trs",
            "description": "specify how many TRs to remove from runs  e.g. -tcat_remove_first_trs 3 e.g. -tcat_remove_first_trs 3 1 0 0 3 default: 0  Since it takes several seconds for the magnetization to reach a steady state (at the beginning of each run), the initial TRs of each run may have values that are significantly greater than the later ones.  This option is used to specify how many TRs to remove from the beginning of every run.  If the number needs to vary across runs, then one number should be specified per run.",
            "id": "__TCAT_REMOVE_FIRST_TRS__",
            "name": "__TCAT_REMOVE_FIRST_TRS__",
            "optional": true,
            "type": "String",
            "value-key": "__TCAT_REMOVE_FIRST_TRS__"
        },
        {
            "command-line-flag": "-tcat_remove_last_trs",
            "description": "specify TRs to remove from run ends  e.g. -tcat_remove_last_trs 10 default: 0  For when the user wants a simple way to shorten each run.  See also -ricor_regs_rm_nlast.",
            "id": "__TCAT_REMOVE_LAST_TRS__",
            "name": "__TCAT_REMOVE_LAST_TRS__",
            "optional": true,
            "type": "String",
            "value-key": "__TCAT_REMOVE_LAST_TRS__"
        },
        {
            "command-line-flag": "-despike_mask",
            "description": "allow Automasking in 3dDespike  By default, -nomask is applied to 3dDespike.  Since anatomical masks will probably not be contained within the Automask operation of 3dDespike (which uses methods akin to '3dAutomask -dilate 4'), it is left up to the user to speed up this operation via masking.  Note that the only case in which this should be done is when applying the EPI mask to the regression.  Please see '3dDespike -help' and '3dAutomask -help' for more information.",
            "id": "__DESPIKE_MASK__",
            "name": "__DESPIKE_MASK__",
            "optional": true,
            "type": "String",
            "value-key": "__DESPIKE_MASK__"
        },
        {
            "command-line-flag": "-despike_new",
            "description": "-despike_new yes/no     : set whether to use new version of 3dDespike  e.g. -despike_new no default: yes  There is a '-NEW' option/method in 3dDespike which runs a faster method than the previous L1-norm method (Nov 2013).  The results are similar but not identical (different fits).  The difference in speed is more dramatic for long time series (> 500 time points).  Use this option to control whether to use the new version.  Sep 2016: in 3dDespike, -NEW is now the default if the input is longer than 500 time points.  In such a case -despike_new has no effect.  See also env var AFNI_3dDespike_NEW and '3dDespike -help' for more information.",
            "id": "__DESPIKE_NEW__",
            "name": "__DESPIKE_NEW__",
            "optional": true,
            "type": "String",
            "value-key": "__DESPIKE_NEW__"
        },
        {
            "command-line-flag": "-despike_opts_3dDes",
            "description": "-despike_opts_3dDes OPTS... : specify additional options for 3dDespike  e.g. -despike_opts_3dDes -nomask -ignore 2  By default, 3dDespike is used with only -prefix and -nomask (unless -despike_mask is applied).  Any other options must be applied via -despike_opts_3dDes.  Note that the despike block is not applied by default.  To apply despike in the processing script, use either '-do_block despike' or '-blocks ... despike ...'.  Please see '3dDespike -help' for more information. See also '-do_blocks', '-blocks', '-despike_mask'.",
            "id": "__DESPIKE_OPTS_3DDES__",
            "name": "__DESPIKE_OPTS_3DDES__",
            "optional": true,
            "type": "String",
            "value-key": "__DESPIKE_OPTS_3DDES__"
        },
        {
            "command-line-flag": "-ricor_datum",
            "description": "specify output data type from ricor block  e.g. -ricor_datum float  By default, if the input is unscaled shorts, the output will be unscaled shorts.  Otherwise the output will be floats.  The user may override this default with the -ricor_datum option. Currently only 'short' and 'float' are valid parameters.  Note that 3dREMLfit only outputs floats at the moment.  Recall that the down-side of float data is that it takes twice the disk space, compared with shorts (scaled or unscaled).  Please see '3dREMLfit -help' for more information.",
            "id": "__RICOR_DATUM__",
            "name": "__RICOR_DATUM__",
            "optional": true,
            "type": "String",
            "value-key": "__RICOR_DATUM__"
        },
        {
            "command-line-flag": "-ricor_polort",
            "description": "set the polynomial degree for 3dREMLfit  e.g. -ricor_polort 4 default: 1 + floor(run_length / 75.0)  The default polynomial degree to apply during the 'ricor' block is similar to that of the 'regress' block, but is based on twice the run length (and so should be almost twice as large).  This is to account for motion, since volreg has typically not happened yet.  Use -ricor_polort to override the default.",
            "id": "__RICOR_POLORT__",
            "name": "__RICOR_POLORT__",
            "optional": true,
            "type": "String",
            "value-key": "__RICOR_POLORT__"
        },
        {
            "command-line-flag": "-ricor_regress_method",
            "description": "process per-run or across-runs  e.g. -ricor_regress_method across-runs default: NONE: this option is required for a 'ricor' block  * valid METHOD parameters: per-run, across-runs  The cardiac and respiratory signals can be regressed out of each run separately, or out of all runs at once.  The user must choose the method, there is no default.  See \"RETROICOR NOTE\" for more details about the methods.",
            "id": "__RICOR_REGRESS_METHOD__",
            "name": "__RICOR_REGRESS_METHOD__",
            "optional": true,
            "type": "String",
            "value-key": "__RICOR_REGRESS_METHOD__"
        },
        {
            "command-line-flag": "-ricor_regress_solver",
            "description": "regress using OLSQ or REML  e.g. -ricor_regress_solver REML default: OLSQ  * valid METHOD parameters: OLSQ, REML  Use this option to specify the regression method for removing the cardiac and respiratory signals.  The default method is ordinary least squares, removing the \"best fit\" of the card/resp signals from the data (also subject to the polort baseline).  To apply the REML (REstricted Maximum Likelihood) method, use this option.  Note that 3dREMLfit is used for the regression in either case, particularly since the regressors are slice-based (they are different for each slice).  Please see '3dREMLfit -help' for more information.",
            "id": "__RICOR_REGRESS_SOLVER__",
            "name": "__RICOR_REGRESS_SOLVER__",
            "optional": true,
            "type": "String",
            "value-key": "__RICOR_REGRESS_SOLVER__"
        },
        {
            "command-line-flag": "-ricor_regs_nfirst",
            "description": "ignore the first regressor timepoints  e.g. -ricor_regs_nfirst 2 default: 0  This option is similar to -tcat_remove_first_trs.  It is used to remove the first few TRs from the -ricor_regs regressor files.  Since it is likely that the number of TRs in the ricor regressor files matches the number of TRs in the original input dataset (via the -dsets option), it is likely that -ricor_regs_nfirst should match -tcat_remove_first_trs.  See also '-tcat_remove_first_trs', '-ricor_regs', '-dsets'.",
            "id": "__RICOR_REGS_NFIRST__",
            "name": "__RICOR_REGS_NFIRST__",
            "optional": true,
            "type": "String",
            "value-key": "__RICOR_REGS_NFIRST__"
        },
        {
            "command-line-flag": "-ricor_regs_rm_nlast",
            "description": "remove the last NUM TRs from each regressor  e.g. -ricor_regs_rm_nlast 10 default: 0  For when the user wants a simple way to shorten each run.  See also -tcat_remove_last_trs.",
            "id": "__RICOR_REGS_RM_NLAST__",
            "name": "__RICOR_REGS_RM_NLAST__",
            "optional": true,
            "type": "String",
            "value-key": "__RICOR_REGS_RM_NLAST__"
        },
        {
            "command-line-flag": "-tshift_align_to",
            "description": "specify 3dTshift alignment option  e.g. -tshift_align_to -slice 14 default: -tzero 0  By default, each time series is aligned to the beginning of the TR.  This option allows the users to change the alignment, and applies the option parameters directly to the 3dTshift command in the output script.  It is likely that the user will use either '-slice SLICE_NUM' or '-tzero ZERO_TIME'.  Note that when aligning to an offset other than the beginning of the TR, and when applying the -regress_stim_files option, then it may be necessary to also apply -regress_stim_times_offset, to offset timing for stimuli to later within each TR.  Please see '3dTshift -help' for more information. See also '-regress_stim_times_offset'.",
            "id": "__TSHIFT_ALIGN_TO__",
            "name": "__TSHIFT_ALIGN_TO__",
            "optional": true,
            "type": "String",
            "value-key": "__TSHIFT_ALIGN_TO__"
        },
        {
            "command-line-flag": "-tshift_interp",
            "description": "specify the interpolation method for tshift  e.g. -tshift_interp -Fourier e.g. -tshift_interp -cubic default -quintic  Please see '3dTshift -help' for more information.",
            "id": "__TSHIFT_INTERP__",
            "name": "__TSHIFT_INTERP__",
            "optional": true,
            "type": "String",
            "value-key": "__TSHIFT_INTERP__"
        },
        {
            "command-line-flag": "-tshift_opts_ts",
            "description": "-tshift_opts_ts OPTS ... : specify extra options for 3dTshift  e.g. -tshift_opts_ts -tpattern alt+z  This option allows the user to add extra options to the 3dTshift command.  Note that only one -tshift_opts_ts should be applied, which may be used for multiple 3dTshift options.  Please see '3dTshift -help' for more information.",
            "id": "__TSHIFT_OPTS_TS__",
            "name": "__TSHIFT_OPTS_TS__",
            "optional": true,
            "type": "String",
            "value-key": "__TSHIFT_OPTS_TS__"
        },
        {
            "command-line-flag": "-blip_forward_dset",
            "description": "specify a forward blip dataset  e.g. -blip_forward_dset epi_forward_blip+orig'[0..9]'  Without this option, the first TRs of the first input EPI time series would be used as the forward blip dataset.  See also -blip_revers_dset.  Please see '3dQwarp -help' for more information, and the -plusminus option in particular.",
            "id": "__BLIP_FORWARD_DSET__",
            "name": "__BLIP_FORWARD_DSET__",
            "optional": true,
            "type": "String",
            "value-key": "__BLIP_FORWARD_DSET__"
        },
        {
            "command-line-flag": "-blip_reverse_dset",
            "description": "specify a reverse blip dataset  e.g. -blip_reverse_dset epi_reverse_blip+orig e.g. -blip_reverse_dset epi_reverse_blip+orig'[0..9]'  EPI distortion correction can be applied via blip up/blip down acquisitions.  Unless specified otherwise, the first TRs of the first run of typical EPI data specified via -dsets is considered to be the forward direction (blip up, say).  So only the reverse direction data needs separate input.  Please see '3dQwarp -help' for more information, and the -plusminus option in particular.",
            "id": "__BLIP_REVERSE_DSET__",
            "name": "__BLIP_REVERSE_DSET__",
            "optional": true,
            "type": "String",
            "value-key": "__BLIP_REVERSE_DSET__"
        },
        {
            "command-line-flag": "-blip_opts_qw",
            "description": "-blip_opts_qw OPTS ...  : specify extra options for 3dQwarp  e.g. -blip_opts_qw -noXdis -noZdis  This option allows the user to add extra options to the 3dQwarp command specific to the 'blip' processing block.  There are many options (e.g. for blurring) applied in the 3dQwarp command by afni_proc.py by default, so review the resulting script.  Please see '3dQwarp -help' for more information.",
            "id": "__BLIP_OPTS_QW__",
            "name": "__BLIP_OPTS_QW__",
            "optional": true,
            "type": "String",
            "value-key": "__BLIP_OPTS_QW__"
        },
        {
            "command-line-flag": "-tlrc_anat",
            "description": "run @auto_tlrc on '-copy_anat' dataset  e.g. -tlrc_anat  Run @auto_tlrc on the anatomical dataset provided by '-copy_anat'. By default, warp the anat to align with TT_N27+tlrc, unless the '-tlrc_base' option is given.  The -copy_anat option specifies which anatomy to transform.  ** Note, use of this option has the same effect as application of the 'tlrc' block.  Please see '@auto_tlrc -help' for more information. See also -copy_anat, -tlrc_base, -tlrc_no_ss and the 'tlrc' block.",
            "id": "__TLRC_ANAT__",
            "name": "__TLRC_ANAT__",
            "optional": true,
            "type": "String",
            "value-key": "__TLRC_ANAT__"
        },
        {
            "command-line-flag": "-tlrc_base",
            "description": "run \"@auto_tlrc -base BASE_DSET\"  e.g. -tlrc_base TT_icbm452+tlrc default: -tlrc_base TT_N27+tlrc  This option is used to supply an alternate -base dataset for @auto_tlrc (or auto_warp.py).  Otherwise, TT_N27+tlrc will be used.  Note that the default operation of @auto_tlrc is to \"skull strip\" the input dataset.  If this is not appropriate, consider also the '-tlrc_no_ss' option.  Please see '@auto_tlrc -help' for more information. See also -tlrc_anat, -tlrc_no_ss.",
            "id": "__TLRC_BASE__",
            "name": "__TLRC_BASE__",
            "optional": true,
            "type": "String",
            "value-key": "__TLRC_BASE__"
        },
        {
            "command-line-flag": "-tlrc_NL_warp",
            "description": "use non-linear for template alignment  e.g. -tlrc_NL_warp  If this option is applied, then auto_warp.py is applied for the transformation to standard space, rather than @auto_tlrc, which in turn applies 3dQwarp (rather than 3dWarpDrive in @auto_tlrc).  The output datasets from this operation are:  INPUT_ANAT+tlrc         : standard space version of anat anat.un.aff.Xat.1D      : affine xform to standard space anat.un.aff.qw_WARP.nii : non-linear xform to standard space (displacement vectors across volume)  The resulting ANAT dataset is copied out of the awpy directory back into AFNI format, and with the original name but new view, while the 2 transformation files (one text file of 12 numbers, one 3-volume dataset vectors) are moved out with the original names.  If -volreg_tlrc_warp is given, then the non-linear transformation will also be applied to the EPI data, sending the 'volreg' output directly to standard space.  As usual, all transformations are combined so that the EPI is only resampled one time.  Options can be added to auto_warp.py via -tlrc_opts_at.  Consider use of -anat_uniform_method along with this option.  Please see 'auto_warp.py -help' for more information. See also -tlrc_opts_at, -anat_uniform_method.",
            "id": "__TLRC_NL_WARP__",
            "name": "__TLRC_NL_WARP__",
            "optional": true,
            "type": "String",
            "value-key": "__TLRC_NL_WARP__"
        },
        {
            "command-line-flag": "-tlrc_NL_warped_dsets",
            "description": "-tlrc_NL_warped_dsets ANAT WARP.1D NL_WARP: import auto_warp.py output  e.g. -tlrc_NL_warped_dsets anat.nii           \\ anat.un.aff.Xat.1D \\ anat.un.aff.qw_WARP.nii  If the user has already run auto_warp.py on the subject anatomy to transform (non-linear) to standard space, those datasets can be input to save re-processing time.  They are the same 3 files that would be otherwise created by running auto_warp_py from the proc script.  When using this option, the 'tlrc' block will be empty of actions.",
            "id": "__TLRC_NL_WARPED_DSETS__",
            "name": "__TLRC_NL_WARPED_DSETS__",
            "optional": true,
            "type": "String",
            "value-key": "__TLRC_NL_WARPED_DSETS__"
        },
        {
            "command-line-flag": "-tlrc_NL_awpy_rm",
            "description": "-tlrc_NL_awpy_rm Y/N    : specify whether to remove awpy directory  e.g.     -tlrc_NL_awpy_rm no default: -tlrc_NL_awpy_rm yes  The auto_warp.py program does all its work in an sub-directory called 'awpy', which is removed by default.  Use this option with 'no' to save the awpy directory.",
            "id": "__TLRC_NL_AWPY_RM__",
            "name": "__TLRC_NL_AWPY_RM__",
            "optional": true,
            "type": "String",
            "value-key": "__TLRC_NL_AWPY_RM__"
        },
        {
            "command-line-flag": "-tlrc_no_ss",
            "description": "add the -no_ss option to @auto_tlrc  e.g. -tlrc_no_ss  This option is used to tell @auto_tlrc not to perform the skull strip operation.  Please see '@auto_tlrc -help' for more information.",
            "id": "__TLRC_NO_SS__",
            "name": "__TLRC_NO_SS__",
            "optional": true,
            "type": "String",
            "value-key": "__TLRC_NO_SS__"
        },
        {
            "command-line-flag": "-tlrc_opts_at",
            "description": "-tlrc_opts_at OPTS ...   : add additional options to @auto_tlrc  e.g. -tlrc_opts_at -OK_maxite  This option is used to add user-specified options to @auto_tlrc, specifically those afni_proc.py is not otherwise set to handle.  In the case of -tlrc_NL_warp, the options will be passed to auto_warp.py, instead.  Please see '@auto_tlrc -help' for more information. Please see 'auto_warp.py -help' for more information.",
            "id": "__TLRC_OPTS_AT__",
            "name": "__TLRC_OPTS_AT__",
            "optional": true,
            "type": "String",
            "value-key": "__TLRC_OPTS_AT__"
        },
        {
            "command-line-flag": "-tlrc_rmode",
            "description": "apply RMODE resampling in @auto_tlrc  e.g. -tlrc_rmode NN  This option is used to apply '-rmode RMODE' in @auto_tlrc.  Please see '@auto_tlrc -help' for more information.",
            "id": "__TLRC_RMODE__",
            "name": "__TLRC_RMODE__",
            "optional": true,
            "type": "String",
            "value-key": "__TLRC_RMODE__"
        },
        {
            "command-line-flag": "-tlrc_suffix",
            "description": "apply SUFFIX to result of @auto_tlrc  e.g. -tlrc_suffix auto_tlrc  This option is used to apply '-suffix SUFFIX' in @auto_tlrc.  Please see '@auto_tlrc -help' for more information.",
            "id": "__TLRC_SUFFIX__",
            "name": "__TLRC_SUFFIX__",
            "optional": true,
            "type": "String",
            "value-key": "__TLRC_SUFFIX__"
        },
        {
            "command-line-flag": "-align_epi_ext_dset",
            "description": "specify dset/brick for align_epi_anat EPI  e.g. -align_epi_ext_dset subj10/epi_r01+orig'[0]'  This option allows the user to specify an external volume for the EPI base used in align_epi_anat.py in the align block.  The user should apply sub-brick selection if the dataset has more than one volume.  This volume would be used for both the -epi and the",
            "id": "__ALIGN_EPI_EXT_DSET__",
            "name": "__ALIGN_EPI_EXT_DSET__",
            "optional": true,
            "type": "String",
            "value-key": "__ALIGN_EPI_EXT_DSET__"
        },
        {
            "command-line-flag": "-align_epi_strip_method",
            "description": "specify EPI skull strip method in AEA  e.g. -align_epi_strip_method 3dSkullStrip default: 3dAutomask (changed from 3dSkullStrip, 20 Aug, 2013)  When align_epi_anat.py is used to align the EPI and anatomy, it uses 3dSkullStrip to remove non-brain tissue from the EPI dataset. However afni_proc.py changes that to 3dAutomask by default (as of August 20, 2013).  This option can be used to specify which method to use, one of 3dSkullStrip, 3dAutomask or None.  This option assumes the 'align' processing block is used.  Please see \"align_epi_anat.py -help\" for more information. Please see \"3dSkullStrip -help\" for more information. Please see \"3dAutomask -help\" for more information.",
            "id": "__ALIGN_EPI_STRIP_METHOD__",
            "name": "__ALIGN_EPI_STRIP_METHOD__",
            "optional": true,
            "type": "String",
            "value-key": "__ALIGN_EPI_STRIP_METHOD__"
        },
        {
            "command-line-flag": "-align_unifize_epi",
            "description": "-align_unifize_epi yes/no: run uniformity correction on EPI base volume  e.g. -align_unifize_epi yes default: no  Use this option to run \"3dUnifize -T2\" on the vr_base dataset for the purpose of alignment to the anat.  The uniformity corrected volume is only used for anatomical alignment.",
            "id": "__ALIGN_UNIFIZE_EPI__",
            "name": "__ALIGN_UNIFIZE_EPI__",
            "optional": true,
            "type": "String",
            "value-key": "__ALIGN_UNIFIZE_EPI__"
        },
        {
            "command-line-flag": "-volreg_align_e2a",
            "description": "align EPI to anatomy at volreg step  This option is used to align the EPI data to match the anatomy. It is done by applying the inverse of the anatomy to EPI alignment matrix to the EPI data at the volreg step.  The 'align' processing block is required.  At the 'align' block, the anatomy is aligned to the EPI data. When applying the '-volreg_align_e2a' option, the inverse of that a2e transformation (so now e2a) is instead applied to the EPI data.  Note that this e2a transformation is catenated with the volume registration transformations, so that the EPI data is still only resampled the one time.  If the user requests -volreg_tlrc_warp, the +tlrc transformation will also be applied at that step in a single transformation.  See also the 'align' block and '-volreg_tlrc_warp'.",
            "id": "__VOLREG_ALIGN_E2A__",
            "name": "__VOLREG_ALIGN_E2A__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_ALIGN_E2A__"
        },
        {
            "command-line-flag": "-volreg_align_to",
            "description": "specify the base position for volume reg  e.g. -volreg_align_to last e.g. -volreg_align_to MIN_OUTLIER default: third  This option takes 'first', 'third', 'last' or 'MIN_OUTLIER' as a parameter.  It specifies whether the EPI volumes are registered to the first or third volume (of the first run), the last volume (of the last run), or the volume that is consider a minimum outlier. The choice of 'first' or 'third' might correspond with when the anatomy was acquired before the EPI data.  The choice of 'last' might correspond to when the anatomy was acquired after the EPI data.  The default of 'third' was chosen to go a little farther into the steady state data.  Note that this is done after removing any volumes in the initial tcat operation.  * A special case is if POSN is the string MIN_OUTLIER, in which case the volume with the minimum outlier fraction would be used.  Since anat and EPI alignment tends to work very well, the choice of alignment base could even be independent of when the anatomy was acquired, making MIN_OUTLIER a good choice.  Please see '3dvolreg -help' for more information. See also -tcat_remove_first_trs, -volreg_base_ind and -volreg_base_dset.",
            "id": "__VOLREG_ALIGN_TO__",
            "name": "__VOLREG_ALIGN_TO__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_ALIGN_TO__"
        },
        {
            "command-line-flag": "-volreg_base_dset",
            "description": "specify dset/sub-brick for volreg base  e.g. -volreg_base_dset subj10/vreg_base+orig'[0]' e.g. -volreg_base_dset MIN_OUTLIER  This option allows the user to specify an external dataset for the volreg base.  The user should apply sub-brick selection if the dataset has more than one volume.  For example, one might align to a pre-magnetic steady state volume.  Note that unless -align_epi_ext_dset is also applied, this volume will be used for anatomical to EPI alignment (assuming that is being done at all).  * A special case is if DSET is the string MIN_OUTLIER, in which case the volume with the minimum outlier fraction would be used.  See also -align_epi_ext_dset, -volreg_align_to and -volreg_base_ind.",
            "id": "__VOLREG_BASE_DSET__",
            "name": "__VOLREG_BASE_DSET__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_BASE_DSET__"
        },
        {
            "command-line-flag": "-volreg_base_ind",
            "description": "specify run/sub-brick indices for base  e.g. -volreg_base_ind 10 123 default: 0 0  This option allows the user to specify exactly which dataset and sub-brick to use as the base registration image.  Note that the SUB index applies AFTER the removal of pre-steady state images.  * The RUN number is 1-based, matching the run list in the output shell script.  The SUB index is 0-based, matching the sub-brick of EPI time series #RUN.  Yes, one is 1-based, the other is 0-based. Life is hard.  The user can apply only one of the -volreg_align_to and -volreg_base_ind options.  See also -volreg_align_to, -tcat_remove_first_trs and -volreg_base_dset.",
            "id": "__VOLREG_BASE_IND__",
            "name": "__VOLREG_BASE_IND__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_BASE_IND__"
        },
        {
            "command-line-flag": "-volreg_get_allcostX",
            "description": "-volreg_get_allcostX yes/no : compute all anat/EPI costs  e.g. -volreg_get_allcostX no default: yes  By default, given the final anatomical dataset (anat_final) and the the final EPI volreg base (final_epi), this option can be used to compute alignment costs between the two volumes across all cost functions from 3dAllineate.  Effectively, it will add the following to the proc script:  3dAllineate -base FINAL_EPI -input FINAL_ANAT -allcostX  The text output is stored in the file out.allcostX.txt.  This operation is informational only, to help evaluate alignment costs across subjects.  Please see '3dAllineate -help' for more details.",
            "id": "__VOLREG_GET_ALLCOSTX__",
            "name": "__VOLREG_GET_ALLCOSTX__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_GET_ALLCOSTX__"
        },
        {
            "command-line-flag": "-volreg_compute_tsnr",
            "description": "-volreg_compute_tsnr yes/no : compute TSNR datasets from volreg output  e.g. -volreg_compute_tsnr yes default: no  Use this option to compute a temporal signal to noise (TSNR) dataset at the end of the volreg block.  Both the signal and noise datasets are from the run 1 output, where the \"signal\" is the mean and the \"noise\" is the detrended time series.  TSNR = average(signal) / stdev(noise)  See also -regress_compute_tsnr.",
            "id": "__VOLREG_COMPUTE_TSNR__",
            "name": "__VOLREG_COMPUTE_TSNR__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_COMPUTE_TSNR__"
        },
        {
            "command-line-flag": "-volreg_interp",
            "description": "specify the interpolation method for volreg  e.g. -volreg_interp -quintic e.g. -volreg_interp -Fourier default: -cubic  Please see '3dvolreg -help' for more information.",
            "id": "__VOLREG_INTERP__",
            "name": "__VOLREG_INTERP__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_INTERP__"
        },
        {
            "command-line-flag": "-volreg_motsim",
            "description": "generate motion simulated time series  Use of this option will result in a 'motsim' (motion simulation) time series dataset that is akin to an EPI dataset altered only by motion and registration (no BOLD, no signal drift, etc).  This dataset can be used to generate regressors of no interest to be used in the regression block.  rcr - note relevant options once they are in  Please see '@simulate_motion -help' for more information.",
            "id": "__VOLREG_MOTSIM__",
            "name": "__VOLREG_MOTSIM__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_MOTSIM__"
        },
        {
            "command-line-flag": "-volreg_opts_ms",
            "description": "-volreg_opts_ms OPTS ... : specify extra options for @simulate_motion  e.g. -volreg_opts_ms -save_workdir  This option can be used to pass extra options directly to the @simulate_motion command.  See also -volreg_motsim. Please see '@simulate_motion -help' for more information.",
            "id": "__VOLREG_OPTS_MS__",
            "name": "__VOLREG_OPTS_MS__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_OPTS_MS__"
        },
        {
            "command-line-flag": "-volreg_opts_vr",
            "description": "-volreg_opts_vr OPTS ... : specify extra options for 3dvolreg  e.g. -volreg_opts_vr -twopass e.g. -volreg_opts_vr -noclip -nomaxdisp  This option allows the user to add extra options to the 3dvolreg command.  Note that only one -volreg_opts_vr should be applied, which may be used for multiple 3dvolreg options.  Please see '3dvolreg -help' for more information.",
            "id": "__VOLREG_OPTS_VR__",
            "name": "__VOLREG_OPTS_VR__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_OPTS_VR__"
        },
        {
            "command-line-flag": "-volreg_no_extent_mask",
            "description": "do not create and apply extents mask  default: apply extents mask  This option says not to create or apply the extents mask.  The extents mask:  When EPI data is transformed to the anatomical grid in either orig or tlrc space (i.e. if -volreg_align_e2a or -volreg_tlrc_warp is applied), then the complete EPI volume will only cover part of the resulting volume space.  Worse than that, the coverage will vary over time, as motion will alter the final transformation (remember that volreg, EPI->anat and ->tlrc transformations are all combined, to prevent multiple resampling steps).  The result is that edge voxels will sometimes have valid data and sometimes not.  The extents mask is made from an all-1 dataset that is warped with the same per-TR transformations as the EPI data.  The intersection of the result is the extents mask, so that every voxel in the extents mask has data at every time point.  Voxels that are not are missing data from some or all TRs.  It is called the extents mask because it defines the 'bounding box' of valid EPI data.  It is not quite a tiled box though, as motion changes the location slightly, per TR.  See also -volreg_align_e2a, -volreg_tlrc_warp. See also the 'extents' mask, in the \"MASKING NOTE\" section above.",
            "id": "__VOLREG_NO_EXTENT_MASK__",
            "name": "__VOLREG_NO_EXTENT_MASK__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_NO_EXTENT_MASK__"
        },
        {
            "command-line-flag": "-volreg_regress_per_run",
            "description": "regress motion parameters from each run  === This option has been replaced by -regress_motion_per_run. ===",
            "id": "__VOLREG_REGRESS_PER_RUN__",
            "name": "__VOLREG_REGRESS_PER_RUN__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_REGRESS_PER_RUN__"
        },
        {
            "command-line-flag": "-volreg_tlrc_adwarp",
            "description": "warp EPI to +tlrc space at end of volreg step  default: stay in +orig space  With this option, the EPI data will be warped to standard space (via adwarp) at the end of the volreg processing block.  Further processing through regression will be done in standard space.  This option is useful for applying a manual Talairach transform, which does not work with -volreg_tlrc_warp.  To apply one from @auto_tlrc, -volreg_tlrc_warp is recommended.  The resulting voxel grid is the minimum dimension, truncated to 3 significant bits.  See -volreg_warp_dxyz for details.  Note: this step requires a transformed anatomy, which can come from the -tlrc_anat option or from -copy_anat importing an existing one.  Please see 'WARP TO TLRC NOTE' above, for additional details. See also -volreg_tlrc_warp, -volreg_warp_dxyz, -tlrc_anat, -copy_anat.",
            "id": "__VOLREG_TLRC_ADWARP__",
            "name": "__VOLREG_TLRC_ADWARP__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_TLRC_ADWARP__"
        },
        {
            "command-line-flag": "-volreg_tlrc_warp",
            "description": "warp EPI to +tlrc space at volreg step  default: stay in +orig space  With this option, the EPI data will be warped to standard space in the volreg processing block.  All further processing through regression will be done in standard space.  Warping is done with volreg to apply both the volreg and tlrc transformations in a single step (so a single interpolation of the EPI data).  The volreg transformations (for each volume) are stored and multiplied by the +tlrc transformation, while the volume registered EPI data is promptly ignored.  The volreg/tlrc (affine or non-linear) transformation is then applied as a single concatenated warp to the unregistered data.  Note that the transformation concatenation is not possible when using the 12-piece manual transformation (see -volreg_tlrc_adwarp for details).  The resulting voxel grid is the minimum dimension, truncated to 3 significant bits.  See -volreg_warp_dxyz for details.  Note: this step requires a transformed anatomy, which can come from the -tlrc_anat option or from -copy_anat importing an existing one.  Please see 'WARP TO TLRC NOTE' above, for additional details. See also -volreg_tlrc_adwarp, -volreg_warp_dxyz, -tlrc_anat, -copy_anat.",
            "id": "__VOLREG_TLRC_WARP__",
            "name": "__VOLREG_TLRC_WARP__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_TLRC_WARP__"
        },
        {
            "command-line-flag": "-volreg_warp_dxyz",
            "description": "grid dimensions for _align_e2a or _tlrc_warp  e.g. -volreg_warp_dxyz 3.5 default: min dim truncated to 3 significant bits (see description, below)  This option allows the user to specify the grid size for output datasets from the -volreg_tlrc_warp and -volreg_align_e2a options. In either case, the output grid will be isotropic voxels (cubes).  By default, DXYZ is the minimum input dimension, truncated to 3 significant bits (for integers, starts affecting them at 9, as 9 requires 4 bits to represent).  Some examples: ----------------------------  (integer range, so >= 4) 8.00   ...  9.99   --> 8.0 ... 4.00   ...  4.99   --> 4.0 ----------------------------  (3 significant bits) 2.50   ...  2.99   --> 2.5 2.00   ...  2.49   --> 2.0 1.75   ...  1.99   --> 1.75 1.50   ...  1.74   --> 1.5 1.25   ...  1.49   --> 1.25 1.00   ...  1.24   --> 1.0 0.875  ...  0.99   --> 0.875 0.75   ...  0.874  --> 0.75 0.625  ...  0.74   --> 0.625 0.50   ...  0.624  --> 0.50 0.4375 ...  0.49   --> 0.4375 0.375  ...  0.4374 --> 0.375 ...",
            "id": "__VOLREG_WARP_DXYZ__",
            "name": "__VOLREG_WARP_DXYZ__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_WARP_DXYZ__"
        },
        {
            "command-line-flag": "-volreg_zpad",
            "description": "specify number of slices for -zpad  e.g. -volreg_zpad 4 default: -volreg_zpad 1  This option allows the user to specify the number of slices applied via the -zpad option to 3dvolreg.",
            "id": "__VOLREG_ZPAD__",
            "name": "__VOLREG_ZPAD__",
            "optional": true,
            "type": "String",
            "value-key": "__VOLREG_ZPAD__"
        },
        {
            "command-line-flag": "-surf_A",
            "description": "specify first surface for mapping  e.g. -surf_A smoothwm default: -surf_A smoothwm  This option allows the user to specify the first (usually inner) surface for use when mapping from the volume and for blurring. If the option is not given, the smoothwm surface will be assumed.",
            "id": "__SURF_A__",
            "name": "__SURF_A__",
            "optional": true,
            "type": "String",
            "value-key": "__SURF_A__"
        },
        {
            "command-line-flag": "-surf_B",
            "description": "specify second surface for mapping  e.g. -surf_B pial default: -surf_B pial  This option allows the user to specify the second (usually outer) surface for use when mapping from the volume (not for blurring). If the option is not given, the pial surface will be assumed.",
            "id": "__SURF_B__",
            "name": "__SURF_B__",
            "optional": true,
            "type": "String",
            "value-key": "__SURF_B__"
        },
        {
            "command-line-flag": "-surf_blur_fwhm",
            "description": "NO LONGER VALID  Please use -blur_size, instead.",
            "id": "__SURF_BLUR_FWHM__",
            "name": "__SURF_BLUR_FWHM__",
            "optional": true,
            "type": "String",
            "value-key": "__SURF_BLUR_FWHM__"
        },
        {
            "command-line-flag": "-blur_filter",
            "description": "specify 3dmerge filter option  e.g. -blur_filter -1blur_rms default: -1blur_fwhm  This option allows the user to specify the filter option from 3dmerge.  Note that only the filter option is set here, not the filter size.  The two parts were separated so that users might generally worry only about the filter size.  Please see '3dmerge -help' for more information. See also -blur_size.",
            "id": "__BLUR_FILTER__",
            "name": "__BLUR_FILTER__",
            "optional": true,
            "type": "String",
            "value-key": "__BLUR_FILTER__"
        },
        {
            "command-line-flag": "-blur_in_automask",
            "description": "apply 3dBlurInMask -automask  This option forces use of 3dBlurInMask -automask, regardless of whether other masks exist and are being applied.  Note that one would not want to apply -automask via -blur_opts_BIM, as that might result in failure because of multiple -mask options.  Note that -blur_in_automask implies '-blur_in_mask yes'.  Please see '3dBlurInMask -help' for more information. See also -blur_in_mask, -blur_opts_BIM.",
            "id": "__BLUR_IN_AUTOMASK__",
            "name": "__BLUR_IN_AUTOMASK__",
            "optional": true,
            "type": "String",
            "value-key": "__BLUR_IN_AUTOMASK__"
        },
        {
            "command-line-flag": "-blur_opts_BIM",
            "description": "-blur_opts_BIM OPTS ...  : specify extra options for 3dBlurInMask  e.g. -blur_opts_BIM -automask  This option allows the user to add extra options to the 3dBlurInMask command.  Only one -blur_opts_BIM should be applied, which may be used for multiple 3dBlurInMask options.  This option is only useful when '-blur_in_mask yes' is applied.  Please see '3dBlurInMask -help' for more information. See also -blur_in_mask.",
            "id": "__BLUR_OPTS_BIM__",
            "name": "__BLUR_OPTS_BIM__",
            "optional": true,
            "type": "String",
            "value-key": "__BLUR_OPTS_BIM__"
        },
        {
            "command-line-flag": "-blur_opts_merge",
            "description": "-blur_opts_merge OPTS ... : specify extra options for 3dmerge  e.g. -blur_opts_merge -2clip -20 50  This option allows the user to add extra options to the 3dmerge command.  Note that only one -blur_opts_merge should be applied, which may be used for multiple 3dmerge options.  Please see '3dmerge -help' for more information.",
            "id": "__BLUR_OPTS_MERGE__",
            "name": "__BLUR_OPTS_MERGE__",
            "optional": true,
            "type": "String",
            "value-key": "__BLUR_OPTS_MERGE__"
        },
        {
            "command-line-flag": "-blur_size",
            "description": "specify the size, in millimeters  e.g. -blur_size 6.0 default: 4  This option allows the user to specify the size of the blur used by 3dmerge (or another applied smoothing program).  It is applied as the 'bmm' parameter in the filter option (such as -1blur_fwhm) in 3dmerge.  Note the relationship between blur sizes, as used in 3dmerge:  sigma = 0.57735027 * rms = 0.42466090 * fwhm (implying fwhm = 1.359556 * rms)  Programs 3dmerge and 3dBlurInMask apply -blur_size as an additional gaussian blur.  Therefore smoothing estimates should be computed per subject for the correction for multiple comparisons.  Programs 3dBlurToFWHM and SurfSmooth apply -blur_size as the resulting blur, and so do not requre blur estimation.  Please see '3dmerge -help'      for more information. Please see '3dBlurInMask -help' for more information. Please see '3dBlurToFWHM -help' for more information. Please see 'SurfSmooth -help'   for more information. See also -blur_filter.",
            "id": "__BLUR_SIZE__",
            "name": "__BLUR_SIZE__",
            "optional": true,
            "type": "String",
            "value-key": "__BLUR_SIZE__"
        },
        {
            "command-line-flag": "-blur_to_fwhm",
            "description": "blur TO the blur size (not add a blur size)  This option changes the program used to blur the data.  Instead of using 3dmerge, this applies 3dBlurToFWHM.  So instead of adding a blur of size -blur_size (with 3dmerge), the data is blurred TO the FWHM of the -blur_size.  Note that 3dBlurToFWHM should be run with a mask.  So either: o  put the 'mask' block before the 'blur' block, or o  use -blur_in_automask It is not appropriate to include non-brain in the blur estimate.  Note that extra options can be added via -blur_opts_B2FW.  Please see '3dBlurToFWHM -help' for more information. See also -blur_size, -blur_in_automask, -blur_opts_B2FW.",
            "id": "__BLUR_TO_FWHM__",
            "name": "__BLUR_TO_FWHM__",
            "optional": true,
            "type": "String",
            "value-key": "__BLUR_TO_FWHM__"
        },
        {
            "command-line-flag": "-blur_opts_B2FW",
            "description": "-blur_opts_B2FW OPTS ... : specify extra options for 3dBlurToFWHM  e.g. -blur_opts_B2FW -rate 0.2 -temper  This allows the user to add extra options to the 3dBlurToFWHM command.  Note that only one -blur_opts_B2FW should be applied, which may be used for multiple 3dBlurToFWHM options.  Please see '3dBlurToFWHM -help' for more information.",
            "id": "__BLUR_OPTS_B2FW__",
            "name": "__BLUR_OPTS_B2FW__",
            "optional": true,
            "type": "String",
            "value-key": "__BLUR_OPTS_B2FW__"
        },
        {
            "command-line-flag": "-mask_apply",
            "description": "specify which mask to apply in regression  e.g. -mask_apply group  If possible, masks will be made for the EPI data, the subject anatomy, the group anatomy and EPI warp extents.  This option is used to specify which of those masks to apply to the regression.  Valid choices: epi, anat, group, extents.  A subject 'anat' mask will be created if the EPI anat anatomy are aligned, or if the EPI data is warped to standard space via the anat transformation.  In any case, a skull-stripped anat will exist.  A 'group' anat mask will be created if the 'tlrc' block is used (via the -blocks or -tlrc_anat options).  In such a case, the anat template will be made into a binary mask.  This option makes -regress_apply_mask obsolete.  See \"MASKING NOTE\" and \"DEFAULTS\" for details. See also -blocks.",
            "id": "__MASK_APPLY__",
            "name": "__MASK_APPLY__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_APPLY__"
        },
        {
            "command-line-flag": "-mask_dilate",
            "description": "specify the automask dilation  e.g. -mask_dilate 3 default: 1  By default, the masks generated from the EPI data are dilated by 1 step (voxel), via the -dilate option in 3dAutomask.  With this option, the user may specify the dilation.  Valid integers must be at least zero.  Note that 3dAutomask dilation is a little different from the natural voxel-neighbor dilation.  Please see '3dAutomask -help' for more information. See also -mask_type.",
            "id": "__MASK_DILATE__",
            "name": "__MASK_DILATE__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_DILATE__"
        },
        {
            "command-line-flag": "-mask_import",
            "description": "import a final grid mask with the given label  e.g. -mask_import Tvent template_ventricle_3mm+tlrc  Use this option to import a mask that is aligned with the final EPI data _and_ is on the final grid.  o  this might be based on the group template o  this should already be resampled appropriately o  no warping or resampling will be done to this dataset  This mask can be applied via LABEL as other masks, using options like: -regress_ROI, -regress_ROI_PC, -regress_make_corr_vols, -regress_anaticor_label, -mask_intersect, -mask_union.  For example, one might import a ventricle mask from the template, intersect it with the subject specific CSFe (eroded CSF) mask, and possibly take the union with WMe (eroded white matter), before using the result for principle component regression, as in:  -mask_import Tvent template_ventricle_3mm+tlrc \\ -mask_intersect Svent CSFe Tvent               \\ -mask_union WM_vent Svent WMe                  \\",
            "id": "__MASK_IMPORT__",
            "name": "__MASK_IMPORT__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_IMPORT__"
        },
        {
            "command-line-flag": "-mask_intersect",
            "description": "intersect 2 masks  e.g. -mask_intersect Svent CSFe Tvent  Use this option to intersect 2 known masks to create a new mask. NEW_LABEL will be the label of the result, while MASK_A and MASK_B should be labels for existing masks.  One could use this to intersect a template ventricle mask with each subject's specific CSFe (eroded CSF) mask from 3dSeg, for example.  See -mask_import for more details.",
            "id": "__MASK_INTERSECT__",
            "name": "__MASK_INTERSECT__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_INTERSECT__"
        },
        {
            "command-line-flag": "-mask_union",
            "description": "take union of 2 masks  e.g. -mask_union WM_vent Svent WMe  Use this option to take the union of 2 known masks to create a new mask.  NEW_LABEL will be the label of the result, while MASK_A and MASK_B should be labels for existing masks.  One could use this to create union of CSFe and WMe for principle component regression, for example.  See -mask_import for more details.",
            "id": "__MASK_UNION__",
            "name": "__MASK_UNION__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_UNION__"
        },
        {
            "command-line-flag": "-mask_rm_segsy",
            "description": "-mask_rm_segsy Y/N  : choose whether to delete the Segsy directory  e.g. -mask_rm_segsy no default: yes  This option is a companion to -mask_segment_anat.  In the case of running 3dSeg to segment the anatomy, a resulting Segsy directory is created.  Since the main result is a Classes dataset, and to save disk space, the Segsy directory is removed by default.  Use this option to preserve it.  See also -mask_segment_anat.",
            "id": "__MASK_RM_SEGSY__",
            "name": "__MASK_RM_SEGSY__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_RM_SEGSY__"
        },
        {
            "command-line-flag": "-mask_test_overlap",
            "description": "-mask_test_overlap Y/N  : choose whether to test anat/EPI mask overlap  e.g. -mask_test_overlap No default: Yes  If the subject anatomy and EPI masks are computed, then the default operation is to run 3dABoverlap to evaluate the overlap between the two masks.  Output is saved in a text file.  This option allows one to disable such functionality.  Please see '3dABoverlap -help' for more information.",
            "id": "__MASK_TEST_OVERLAP__",
            "name": "__MASK_TEST_OVERLAP__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_TEST_OVERLAP__"
        },
        {
            "command-line-flag": "-mask_type",
            "description": "specify 'union' or 'intersection' mask type  e.g. -mask_type intersection default: union  This option is used to specify whether the mask applied to the analysis is the union of masks from each run, or the intersection. The only valid values for TYPE are 'union' and 'intersection'.  This is not how to specify whether a mask is created, that is done via the 'mask' block with the '-blocks' option.  Please see '3dAutomask -help', '3dMean -help' or '3dcalc -help'. See also -mask_dilate, -blocks.",
            "id": "__MASK_TYPE__",
            "name": "__MASK_TYPE__",
            "optional": true,
            "type": "String",
            "value-key": "__MASK_TYPE__"
        },
        {
            "command-line-flag": "-combine_opts_tedana",
            "description": "-combine_opts_tedana OPT OPT ... : specify extra options for tedana.py  e.g. -combine_opts_tedana --sourceTEs=-1 --kdaw=10 --rdaw=1  Use this option to pass extra options through to tedana.py. This applies to any tedana-based -combine_method.  See also -combine_method.",
            "id": "__COMBINE_OPTS_TEDANA__",
            "name": "__COMBINE_OPTS_TEDANA__",
            "optional": true,
            "type": "String",
            "value-key": "__COMBINE_OPTS_TEDANA__"
        },
        {
            "command-line-flag": "-combine_opts_tedwrap",
            "description": "-combine_opts_tedwrap OPT OPT ... : pass options to tedana_wrapper.py  e.g. -combine_opts_tedwrap -tedana_is_exec  Use this option to pass extra options to tedana_wrapper.py. This applies to any tedana-based -combine_method.",
            "id": "__COMBINE_OPTS_TEDWRAP__",
            "name": "__COMBINE_OPTS_TEDWRAP__",
            "optional": true,
            "type": "String",
            "value-key": "__COMBINE_OPTS_TEDWRAP__"
        },
        {
            "command-line-flag": "-combine_tedana_path",
            "description": "specify path to tedana.py  e.g. -combine_tedana_path ~/testbin/meica.libs/tedana.py default: from under afni binaries directory  If one wishes to use a version of tedana.py other than what comes with AFNI, this option allows one to specify that file.  This applies to any tedana-based -combine_method.  See also -combine_method.",
            "id": "__COMBINE_TEDANA_PATH__",
            "name": "__COMBINE_TEDANA_PATH__",
            "optional": true,
            "type": "String",
            "value-key": "__COMBINE_TEDANA_PATH__"
        },
        {
            "command-line-flag": "-scale_max_val",
            "description": "specify the maximum value for scaled data  e.g. -scale_max_val 1000 default 200  The scale step multiples the time series for each voxel by a scalar so that the mean for that particular run is 100 (allowing interpretation of EPI values as a percentage of the mean).  Values of 200 represent a 100% change above the mean, and so can probably be considered garbage (or the voxel can be considered non-brain).  The output values are limited so as not to sacrifice the precision of the values of short datasets.  Note that in a short (2-byte integer) dataset, a large range of values means bits of accuracy are lost for the representation.  No max will be applied if MAX is <= 100.  Please see 'DATASET TYPES' in the output of '3dcalc -help'. See also -scale_no_max.",
            "id": "__SCALE_MAX_VAL__",
            "name": "__SCALE_MAX_VAL__",
            "optional": true,
            "type": "String",
            "value-key": "__SCALE_MAX_VAL__"
        },
        {
            "command-line-flag": "-scale_no_max",
            "description": "do not apply a limit to the scaled values  The default limit for scaled data is 200.  Use of this option will remove any limit from being applied.  A limit on the scaled data is highly encouraged when working with 'short' integer data, especially when not applying a mask.  See also -scale_max_val.",
            "id": "__SCALE_NO_MAX__",
            "name": "__SCALE_NO_MAX__",
            "optional": true,
            "type": "String",
            "value-key": "__SCALE_NO_MAX__"
        },
        {
            "command-line-flag": "-regress_3dD_stop",
            "description": "3dDeconvolve should stop after X-matrix gen  Use this option to tell 3dDeconvolve to stop after generating the X-matrix (via -x1D_stop).  This is useful if the user only wishes to run the regression through 3dREMLfit.  See also -regress_reml_exec.",
            "id": "__REGRESS_3DD_STOP__",
            "name": "__REGRESS_3DD_STOP__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_3DD_STOP__"
        },
        {
            "command-line-flag": "-regress_anaticor",
            "description": "generate errts using ANATICOR method  Apply the ANATICOR method of HJ Jo, regressing out the WMeLocal time series, which varies across voxels.  WMeLocal is the average time series from all voxels within 45 mm which are in the eroded white matter mask.  The script will run the standard regression via 3dDeconvolve (or stop after setting up the X-matrix, if the user says to), and use that X-matrix, possibly censored, in 3dTproject.  The WMeLocal time series is applied along with the X-matrix to get the result.  Note that other 4-D time series might be regressed out via the 3dTproject step, as well.  In the case of task-based ANATICOR, -regress_reml_exec is required, which uses 3dREMLfit to regress the voxel-wise ANATICOR regressors.  This option implies -mask_segment_anat and -mask_segment_erode.  * Consider use of -regress_anaticor_fast, instead.  Please see \"@ANATICOR -help\" for more detail, including the paper reference for the method. See also -mask_segment_anat, -mask_segment_erode, -regress_3dD_stop. See also -regress_reml_exec.",
            "id": "__REGRESS_ANATICOR__",
            "name": "__REGRESS_ANATICOR__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_ANATICOR__"
        },
        {
            "command-line-flag": "-regress_anaticor_label",
            "description": "specify LABEL for ANATICOR ROI  To go with either -regress_anaticor or -regress_anaticor_fast, this option is used the specifiy an alternate label of an ROI mask to be used in the ANATICOR step.  The default LABEL is WMe (eroded white matter from 3dSeg).  When this option is included, it is up to the user to make sure afni_proc.py has such a label, either by including options:",
            "id": "__REGRESS_ANATICOR_LABEL__",
            "name": "__REGRESS_ANATICOR_LABEL__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_ANATICOR_LABEL__"
        },
        {
            "command-line-flag": "-regress_anaticor_radius",
            "description": "specify RADIUS for 3dLocalstat  To go with -regress_anaticor, use this option to specify the radius of spheres within which local white matter is averaged.  A small radius means the white matter is more local.  It is also faster.  If no white matter is found within the specified distance of some voxel, the effect is that ANATICOR will simply not happen at that voxel.  That is a reasonable \"failure\" case, in that it says there is simply no white matter close enough to regress out (again, at the given voxel).  See also -regress_anaticor.",
            "id": "__REGRESS_ANATICOR_RADIUS__",
            "name": "__REGRESS_ANATICOR_RADIUS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_ANATICOR_RADIUS__"
        },
        {
            "command-line-flag": "-regress_anaticor_fast",
            "description": "generate errts using fast ANATICOR method  This applies basically the same method as with -regress_anaticor, above.  While -regress_anaticor creates WMeLocal dataset by getting the average white matter voxel within a fixed radius, the 'fast' method computes it by instead integrating the white matter over a gaussian curve.  There some basic effects of using the 'fast' method:  1. Using a Gaussian curve to compute each voxel-wise regressor gives more weight to the white matter that is closest to each given voxel.  The FWHM of this 3D kernel is specified by -regress_anaticor_fwhm, with a default of 30 mm.  2. If there is no close white matter (e.g. due to a poor segmentation), the Gaussian curve will likely find white matter far away, instead of creating an empty regressor.  3. This is quite a bit faster, because it is done by creating a time series of all desired white matter voxels, blurring it, and then just regressing out that dataset.  The blur operation is much faster than a localstat one.  Please see \"@ANATICOR -help\" for more detail, including the paper reference for the method. See also -regress_anaticor_fwhm/ See also -mask_segment_anat, -mask_segment_erode, -regress_3dD_stop. See also -regress_anaticor.",
            "id": "__REGRESS_ANATICOR_FAST__",
            "name": "__REGRESS_ANATICOR_FAST__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_ANATICOR_FAST__"
        },
        {
            "command-line-flag": "-regress_anaticor_fwhm",
            "description": "specify FWHM for 'fast' ANATICOR, in mm  e.g.     -regress_anaticor_fwhm 20 default: -regress_anaticor_fwhm 30  This option applies to -regress_anaticor_fast.  The 'fast' ANATICOR method blurs the time series of desired white matter voxels using a Gaussian kernel with the given FWHM (full width at half maximum).  To understand the FWHM, note that it is essentially the diameter of a sphere where the contribution from points at that distance (FWHM/2) contribute half as much as the center point.  For example, if FWHM=10mm, then any voxel at a distance of 5 mm would contribute half as much as a voxel at the center of the kernel.  See also -regress_anaticor_fast.",
            "id": "__REGRESS_ANATICOR_FWHM__",
            "name": "__REGRESS_ANATICOR_FWHM__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_ANATICOR_FWHM__"
        },
        {
            "command-line-flag": "-regress_apply_mask",
            "description": "apply the mask during scaling and regression  By default, any created union mask is not applied to the analysis. Use this option to apply it.  ** This option is essentially obsolete.  Please consider -mask_apply as a preferable option to choose which mask to apply.  See \"MASKING NOTE\" and \"DEFAULTS\" for details. See also -blocks, -mask_apply.",
            "id": "__REGRESS_APPLY_MASK__",
            "name": "__REGRESS_APPLY_MASK__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_APPLY_MASK__"
        },
        {
            "command-line-flag": "-regress_apply_ricor",
            "description": "-regress_apply_ricor yes/no : apply ricor regs in final regression  e.g.     -regress_apply_ricor yes default: no  This is from a change in the default behavior 30 Jan 2012.  Prior to then, the 13 (?) ricor regressors from slice 0 would be applied in the final regression (mostly accounting for degrees of freedom). But since resting state analysis relies on a subsequent correlation analysis, it seems cleaner not to regress them (a second time).",
            "id": "__REGRESS_APPLY_RICOR__",
            "name": "__REGRESS_APPLY_RICOR__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_APPLY_RICOR__"
        },
        {
            "command-line-flag": "-regress_bandpass",
            "description": "bandpass the frequency range  e.g.  -regress_bandpass 0.01 0.1  This option is intended for use in resting state analysis.  Use this option to perform bandpass filtering during the linear regression.  While such an operation is slow (much slower than the FFT using 3dBandpass), doing it during the regression allows one to perform (e.g. motion) censoring at the same time.  This option has a similar effect to running 3dBandpass, e.g. the example of '-regress_bandpass 0.01 0.1' is akin to running:  3dBandpass -ort motion.1D -band 0.01 0.1  except that it is done in 3dDeconvolve using linear regression. And censoring is easy in the context of regression.  Note that the Nyquist frequency is 0.5/TR.  That means that if the TR were >= 5 seconds, there would be no frequencies within the band range of 0.01 to 0.1 to filter.  So there is no point to such an operation.  On the flip side, if the TR is 1.0 second or shorter, the range of 0.01 to 0.1 would remove about 80% of the degrees of freedom (since everything above 0.1 is filtered/removed, up through 0.5).  This might result in a model that is overfit, where there are almost as many (or worse, more) regressors than time points to fit.  So a 0.01 to 0.1 bandpass filter might make the most sense for a TR in [2.0, 3.0], or so.  A different filter range would affect this, of course.  See also -regress_censor_motion.",
            "id": "__REGRESS_BANDPASS__",
            "name": "__REGRESS_BANDPASS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_BANDPASS__"
        },
        {
            "command-line-flag": "-regress_basis",
            "description": "specify the regression basis function  e.g. -regress_basis 'BLOCK(4,1)' e.g. -regress_basis 'BLOCK(5)' e.g. -regress_basis 'TENT(0,14,8)' default: GAM  This option is used to set the basis function used by 3dDeconvolve in the regression step.  This basis function will be applied to all user-supplied regressors (please let me know if there is need to apply different basis functions to different regressors).  ** Note that use of dmBLOCK requires -stim_times_AM1 (or AM2).  So consider option -regress_stim_types.  ** If using -regress_stim_types 'file' for a particular regressor, the basis function will be ignored.  In such a case, it is safest to use 'NONE' for the corresponding basis function.  Please see '3dDeconvolve -help' for more information, or the link: https://afni.nimh.nih.gov/afni/doc/misc/3dDeconvolveSummer2004 See also -regress_basis_normall, -regress_stim_times,",
            "id": "__REGRESS_BASIS__",
            "name": "__REGRESS_BASIS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_BASIS__"
        },
        {
            "command-line-flag": "-regress_basis_normall",
            "description": "specify the magnitude of basis functions  e.g. -regress_basis_normall 1.0  This option is used to set the '-basis_normall' parameter in 3dDeconvolve.  It specifies the height of each basis function.  For the example basis functions, -basis_normall is not recommended.  Please see '3dDeconvolve -help' for more information. See also -regress_basis.",
            "id": "__REGRESS_BASIS_NORMALL__",
            "name": "__REGRESS_BASIS_NORMALL__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_BASIS_NORMALL__"
        },
        {
            "command-line-flag": "-regress_censor_extern",
            "description": "-regress_censor_extern CENSOR.1D : supply an external censor file  e.g. -regress_censor_extern censor_bad_trs.1D  This option is used to provide an initial censor file, if there is some censoring that is desired beyond the automated motion and outlier censoring.  Any additional censoring (motion or outliers) will be combined.  See also -regress_censor_motion, -regress_censor_outliers.",
            "id": "__REGRESS_CENSOR_EXTERN__",
            "name": "__REGRESS_CENSOR_EXTERN__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_CENSOR_EXTERN__"
        },
        {
            "command-line-flag": "-regress_censor_motion",
            "description": "censor TRs with excessive motion  e.g. -regress_censor_motion 0.3  This option is used to censor TRs where the subject moved too much. \"Too much\" is decided by taking the derivative of the motion parameters (ignoring shifts between runs) and the sqrt(sum squares) per TR.  If this Euclidean Norm exceeds the given LIMIT, the TR will be censored.  This option will result in the creation of 3 censor files:  motion_$subj_censor.1D motion_$subj_CENSORTR.txt motion_$subj_enorm.1D  motion_$subj_censor.1D is a 0/1 columnar file to be applied to 3dDeconvolve via -censor.  A row with a 1 means to include that TR, while a 0 means to exclude (censor) it.  motion_$subj_CENSORTR.txt is a short text file listing censored TRs, suitable for use with the -CENSORTR option in 3dDeconvolve. The -censor option is the one applied however, so this file is not used, but may be preferable for users to have a quick peek at.  motion_$subj_enorm.1D is the time series that the LIMIT is applied to in deciding which TRs to censor.  It is the Euclidean norm of the derivatives of the motion parameters.  Plotting this will give users a visual indication of why TRs were censored.  By default, the TR prior to the large motion derivative will also be censored.  To turn off that behavior, use -regress_censor_prev with parameter 'no'.  If censoring the first few TRs from each run is also necessary, use -regress_censor_first_trs.  Please see '1d_tool.py -help' for information on censoring motion. See also -regress_censor_prev and -regress_censor_first_trs.",
            "id": "__REGRESS_CENSOR_MOTION__",
            "name": "__REGRESS_CENSOR_MOTION__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_CENSOR_MOTION__"
        },
        {
            "command-line-flag": "-regress_censor_first_trs",
            "description": "censor the first N TRs in each run  e.g.     -regress_censor_first_trs 3 default: N = 0  If, for example, censoring the first 3 TRs per run is desired, a user might add \"-CENSORTR '*:0-2'\" to the -regress_opts_3dD option. However, when using -regress_censor_motion, these censoring options must be combined into one for 3dDeconvolve.  The -regress_censor_first_trs censors those TRs along with any with large motion.  See '-censor_first_trs' under '1d_tool.py -help' for details. See also '-regress_censor_motion'.",
            "id": "__REGRESS_CENSOR_FIRST_TRS__",
            "name": "__REGRESS_CENSOR_FIRST_TRS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_CENSOR_FIRST_TRS__"
        },
        {
            "command-line-flag": "-regress_censor_prev",
            "description": "-regress_censor_prev yes/no  : censor TRs preceding large motion  default: -regress_censor_prev yes  Since motion spans two TRs, the derivative is not quite enough information to decide whether it is more appropriate to censor the earlier or later TR.  To error on the safe side, many users choose to censor both.  Use this option to specify whether to include the previous TR when censoring.  By default this option is applied as 'yes'.  Users may elect not not to censor the previous TRs by setting this to 'no'.  See also -regress_censor_motion.",
            "id": "__REGRESS_CENSOR_PREV__",
            "name": "__REGRESS_CENSOR_PREV__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_CENSOR_PREV__"
        },
        {
            "command-line-flag": "-regress_censor_outliers",
            "description": "censor TRs with excessive outliers  e.g. -regress_censor_outliers 0.15  This option is used to censor TRs where too many voxels are flagged as outliers by 3dToutcount.  LIMIT should be in [0.0, 1.0], as it is a limit on the fraction of masked voxels.  '3dToutcount -automask -fraction' is used to output the fraction of (auto)masked voxels that are considered outliers at each TR.  If the fraction of outlier voxels is greater than LIMIT for some TR, that TR is censored out.  Depending on the scanner settings, early TRs might have somewhat higher intensities.  This could lead to the first few TRs of each run being censored.  To avoid censoring the first few TRs of each run, apply the -regress_skip_first_outliers option.  Note that if motion is also being censored, the multiple censor files will be combined (multiplied) before 3dDeconvolve.  See '3dToutcount -help' for more details. See also -regress_skip_first_outliers, -regress_censor_motion.",
            "id": "__REGRESS_CENSOR_OUTLIERS__",
            "name": "__REGRESS_CENSOR_OUTLIERS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_CENSOR_OUTLIERS__"
        },
        {
            "command-line-flag": "-regress_compute_gcor",
            "description": "-regress_compute_gcor yes/no : compute GCOR from unit errts  e.g. -regress_compute_gcor no default: yes  By default, the global correlation (GCOR) is computed from the masked residual time series (errts).  GCOR can be thought of as the result of: A1. compute the correlations of each voxel with every other --> can be viewed as an NMASK x NMASK correlation matrix A2. compute GCOR: the average of the NMASK^2 values  Since step A1 would take a lot of time and disk space, a more efficient computation is desirable: B0. compute USET: scale each voxel time series to unit length B1. compute GMU: the global mean of this unit dataset B2. compute a correlation volume (of each time series with GMU) B3. compute the average of this volume  The actual computation is simplified even further, as steps B2 and B3 combine as the L2 norm of GMU.  The result is: B2'. length(GMU)^2  (or the sum of squares of GMU)  The steps B0, B1 and B2' are performed in the proc script.  Note: This measure of global correlation is a single number in the range [0, 1] (not in [-1, 1] as some might expect).  Note: computation of GCOR requires a residual dataset, an EPI mask, and a volume analysis (no surface at the moment).",
            "id": "__REGRESS_COMPUTE_GCOR__",
            "name": "__REGRESS_COMPUTE_GCOR__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_COMPUTE_GCOR__"
        },
        {
            "command-line-flag": "-regress_compute_tsnr",
            "description": "-regress_compute_tsnr yes/no : compute TSNR datasets from errts  e.g. -regress_compute_tsnr no default: yes  By default, a temporal signal to noise (TSNR) dataset is created at the end of the regress block.  The \"signal\" is the all_runs dataset (input to 3dDeconvolve), and the \"noise\" is the errts dataset (the residuals from 3dDeconvolve).  TSNR is computed (per voxel) as the mean signal divided by the standard deviation of the noise.  TSNR = average(signal) / stdev(noise)  The main difference between the TSNR datasets from the volreg and regress blocks is that the data in the regress block has been smoothed and \"completely\" detrended (detrended according to the regression model: including polort, motion and stim responses).  Use this option to prevent the TSNR dataset computation in the 'regress' block.  See also -volreg_compute_tsnr.",
            "id": "__REGRESS_COMPUTE_TSNR__",
            "name": "__REGRESS_COMPUTE_TSNR__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_COMPUTE_TSNR__"
        },
        {
            "command-line-flag": "-regress_fout",
            "description": "-regress_fout yes/no         : output F-stat sub-bricks  e.g. -regress_fout no default: yes  This option controls whether to apply -fout in 3dDeconvolve.  The default is yes.",
            "id": "__REGRESS_FOUT__",
            "name": "__REGRESS_FOUT__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_FOUT__"
        },
        {
            "command-line-flag": "-regress_make_cbucket",
            "description": "-regress_make_cbucket yes/no : add a -cbucket option to 3dDeconvolve  default: 'no'  Recall that the -bucket dataset (no 'c') contains beta weights and various statistics, but generally not including baseline terms (polort and motion).  The -cbucket dataset (with a 'c') is a little different in that it contains: - ONLY betas (no t-stats, no F-stats, no contrasts) - ALL betas (including baseline terms) So it has one volume (beta) per regressor in the X-matrix.  The use is generally for 3dSynthesize, to recreate time series datasets akin to the fitts, but where the user can request any set of parameters to be included (for example, the polort and the main 2 regressors of interest).  Setting this to 'yes' will result in the -cbucket option being added to the 3dDeconvolve command.  Please see '3dDeconvolve -help' for more details.",
            "id": "__REGRESS_MAKE_CBUCKET__",
            "name": "__REGRESS_MAKE_CBUCKET__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_MAKE_CBUCKET__"
        },
        {
            "command-line-flag": "-regress_mot_as_ort",
            "description": "-regress_mot_as_ort yes/no : regress motion parameters using -ortvec  default: no  By default, motion parameters are applied to 3dvolreg using",
            "id": "__REGRESS_MOT_AS_ORT__",
            "name": "__REGRESS_MOT_AS_ORT__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_MOT_AS_ORT__"
        },
        {
            "command-line-flag": "-stim_file",
            "description": "-stim_file and -stim_base.  Use this option to apply them using",
            "id": "__STIM_FILE__",
            "name": "__STIM_FILE__",
            "optional": true,
            "type": "String",
            "value-key": "__STIM_FILE__"
        },
        {
            "command-line-flag": "-ortvec",
            "description": "-ortvec, instead.  One difference is in having a \"cleaner\" 3dDeconvolve command, without the many extra -stim_file options.  Another is a change in the labels associated with the individual parameters.  Otherwise, all results should be the same.",
            "id": "__ORTVEC__",
            "name": "__ORTVEC__",
            "optional": true,
            "type": "String",
            "value-key": "__ORTVEC__"
        },
        {
            "command-line-flag": "-regress_motion_per_run",
            "description": "regress motion parameters from each run  default: regress motion parameters catenated across runs  By default, motion parameters from the volreg block are catenated across all runs, providing 6 (assuming 3dvolreg) regressors of no interest in the regression block.  With -regress_motion_per_run, the motion parameters from each run are used as separate regressors, providing a total of (6 * nruns) regressors.  This allows for the magnitudes of the regressors to vary over each run, rather than using a single (best) magnitude over all runs. So more motion-correlated variance can be accounted for, at the cost of the extra degrees of freedom (6*(nruns-1)).  This option will apply to all motion regressors, including derivatives (if requested).  ** This option was previously called -volreg_regress_per_run. **",
            "id": "__REGRESS_MOTION_PER_RUN__",
            "name": "__REGRESS_MOTION_PER_RUN__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_MOTION_PER_RUN__"
        },
        {
            "command-line-flag": "-regress_skip_first_outliers",
            "description": "ignore the first NSKIP TRs  e.g. -regress_skip_first_outliers 4 default: 0  When using -regress_censor_outliers, any TR with too high of an outlier fraction will be censored.  But depending on the scanner settings, early TRs might have somewhat higher intensities, leading to them possibly being inappropriately censored.  To avoid censoring any the first few TRs of each run, apply the -regress_skip_first_outliers option.  See also -regress_censor_outliers.",
            "id": "__REGRESS_SKIP_FIRST_OUTLIERS__",
            "name": "__REGRESS_SKIP_FIRST_OUTLIERS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_SKIP_FIRST_OUTLIERS__"
        },
        {
            "command-line-flag": "-regress_compute_fitts",
            "description": "compute fitts via 3dcalc, not 3dDecon  This option is to save memory during 3dDeconvolve, in the case where the user has requested both the fitts and errts datasets.  Normally 3dDeconvolve is used to compute both the fitts and errts time series.  But if memory gets tight, it is worth noting that these datasets are redundant, one can be computed from the other (given the all_runs dataset).  all_runs = fitts + errts  Using -regress_compute_fitts, -fitts is no longer applied in 3dD (though -errts is).  Instead, note that an all_runs dataset is created just after 3dDeconvolve.  After that step, the script will create fitts as (all_runs-errts) using 3dcalc.  Note that computation of both errts and fitts datasets is required for this option to be applied.  See also -regress_est_blur_errts, -regress_errts_prefix, -regress_fitts_prefix and -regress_no_fitts.",
            "id": "__REGRESS_COMPUTE_FITTS__",
            "name": "__REGRESS_COMPUTE_FITTS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_COMPUTE_FITTS__"
        },
        {
            "command-line-flag": "-regress_cormat_warnings",
            "description": "-regress_cormat_warnings Y/N : specify whether to get cormat warnings  e.g. -mask_cormat_warnings No default: Yes  By default, '1d_tool.py -show_cormat_warnings' is run on the regression matrix.  Any large, pairwise correlations are shown in text output (which is also saved to a text file).  This option allows one to disable such functionality.  Please see '1d_tool.py -help' for more details.",
            "id": "__REGRESS_CORMAT_WARNINGS__",
            "name": "__REGRESS_CORMAT_WARNINGS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_CORMAT_WARNINGS__"
        },
        {
            "command-line-flag": "-regress_est_blur_epits",
            "description": "estimate the smoothness of the EPI data  This option specifies to run 3dFWHMx on each of the EPI datasets used for regression, the results of which are averaged.  These blur values are saved to the file blur_est.$subj.1D, along with any similar output from errts.  These blur estimates may be input to AlphaSim, for any multiple testing correction done for this subject.  If AlphaSim is run at the group level, it is reasonable to average these estimates across all subjects (assuming they were scanned with the same protocol and at the same scanner).  The mask block is required for this operation (without which the estimates are not reliable).  Please see '3dFWHMx -help' for more information. See also -regress_est_blur_errts.",
            "id": "__REGRESS_EST_BLUR_EPITS__",
            "name": "__REGRESS_EST_BLUR_EPITS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_EST_BLUR_EPITS__"
        },
        {
            "command-line-flag": "-regress_est_blur_errts",
            "description": "estimate the smoothness of the errts  This option specifies to run 3dFWHMx on the errts dataset, output from the regression (by 3dDeconvolve).  These blur estimates may be input to AlphaSim, for any multiple testing correction done for this subject.  If AlphaSim is run at the group level, it is reasonable to average these estimates across all subjects (assuming they were scanned with the same protocol and at the same scanner).  Note that the errts blur estimates should be not only slightly more accurate than the epits blur estimates, but they should be slightly smaller, too (which is beneficial).  The mask block is required for this operation (without which the estimates are not reliable).  Please see '3dFWHMx -help' for more information. See also -regress_est_blur_epits.",
            "id": "__REGRESS_EST_BLUR_ERRTS__",
            "name": "__REGRESS_EST_BLUR_ERRTS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_EST_BLUR_ERRTS__"
        },
        {
            "command-line-flag": "-regress_errts_prefix",
            "description": "specify a prefix for the -errts option  e.g. -regress_fitts_prefix errts  This option is used to add a -errts option to 3dDeconvolve.  As with -regress_fitts_prefix, only the PREFIX is specified, to which the subject ID will be added.  Please see '3dDeconvolve -help' for more information. See also -regress_fitts_prefix.",
            "id": "__REGRESS_ERRTS_PREFIX__",
            "name": "__REGRESS_ERRTS_PREFIX__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_ERRTS_PREFIX__"
        },
        {
            "command-line-flag": "-regress_fitts_prefix",
            "description": "specify a prefix for the -fitts option  e.g. -regress_fitts_prefix model_fit default: fitts  By default, the 3dDeconvolve command in the script will be given a '-fitts fitts' option.  This option allows the user to change the prefix applied in the output script.  The -regress_no_fitts option can be used to eliminate use of -fitts.  Please see '3dDeconvolve -help' for more information. See also -regress_no_fitts.",
            "id": "__REGRESS_FITTS_PREFIX__",
            "name": "__REGRESS_FITTS_PREFIX__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_FITTS_PREFIX__"
        },
        {
            "command-line-flag": "-regress_global_times",
            "description": "specify -stim_times as global times  default: 3dDeconvolve figures it out, if it can  By default, the 3dDeconvolve determines whether -stim_times files are local or global times by the first line of the file.  If it contains at least 2 times (which include '*' characters), it is considered as local_times, otherwise as global_times.  The -regress_global_times option is mostly added to be symmetric with -regress_local_times, as the only case where it would be needed is when there are other times in the first row, but the should still be viewed as global.  See also -regress_local_times.",
            "id": "__REGRESS_GLOBAL_TIMES__",
            "name": "__REGRESS_GLOBAL_TIMES__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_GLOBAL_TIMES__"
        },
        {
            "command-line-flag": "-regress_local_times",
            "description": "specify -stim_times as local times  default: 3dDeconvolve figures it out, if it can  By default, the 3dDeconvolve determines whether -stim_times files are local or global times by the first line of the file.  If it contains at least 2 times (which include '*' characters), it is considered as local_times, otherwise as global_times.  In the case where the first run has only 1 stimulus (maybe even every run), the user would need to put an extra '*' after the first stimulus time.  If the first run has no stimuli, then two would be needed ('* *'), but only for the first run.  Since this may get confusing, being explicit by adding this option is a reasonable thing to do.  See also -regress_global_times.",
            "id": "__REGRESS_LOCAL_TIMES__",
            "name": "__REGRESS_LOCAL_TIMES__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_LOCAL_TIMES__"
        },
        {
            "command-line-flag": "-regress_iresp_prefix",
            "description": "specify a prefix for the -iresp option  e.g. -regress_iresp_prefix model_fit default: iresp  This option allows the user to change the -iresp prefix applied in the 3dDeconvolve command of the output script.  By default, the 3dDeconvolve command in the script will be given a set of '-iresp iresp' options, one per stimulus type, unless the regression basis function is GAM.  In the case of GAM, the response form is assumed to be known, so there is no need for -iresp.  The stimulus label will be appended to this prefix so that a sample 3dDeconvolve option might look one of these 2 examples:",
            "id": "__REGRESS_IRESP_PREFIX__",
            "name": "__REGRESS_IRESP_PREFIX__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_IRESP_PREFIX__"
        },
        {
            "command-line-flag": "-iresp",
            "description": "-iresp 7 iresp_stim07",
            "id": "__IRESP__",
            "name": "__IRESP__",
            "optional": true,
            "type": "String",
            "value-key": "__IRESP__"
        },
        {
            "command-line-flag": "-regress_make_ideal_sum",
            "description": "-regress_make_ideal_sum IDEAL.1D : create IDEAL.1D file from regressors  e.g. -regress_make_ideal_sum ideal_all.1D  By default, afni_proc.py will compute a 'sum_ideal.1D' file that is the sum of non-polort and non-motion regressors from the X-matrix.  This -regress_make_ideal_sum option is used to specify the output file for that sum (if sum_idea.1D is not desired).  Note that if there is nothing in the X-matrix except for polort and motion regressors, or if 1d_tool.py cannot tell what is in there (if there is no header information), then all columns will be used.  Computing the sum means adding a 1d_tool.py command to figure out which columns should be used in the sum (since mixing GAM, TENT, etc., makes it harder to tell up front), and a 3dTstat command to actually sum those columns of the 1D X-matrix (the X-matrix is output by 3dDeconvolve).  Please see '3dDeconvolve -help', '1d_tool.py -help' and '3dTstat -help'. See also -regress_basis, -regress_no_ideal_sum.",
            "id": "__REGRESS_MAKE_IDEAL_SUM__",
            "name": "__REGRESS_MAKE_IDEAL_SUM__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_MAKE_IDEAL_SUM__"
        },
        {
            "command-line-flag": "-regress_motion_file",
            "description": "-regress_motion_file FILE.1D  : use FILE.1D for motion parameters  e.g. -regress_motion_file motion.1D  Particularly if the user performs motion correction outside of afni_proc.py, they may wish to specify a motion parameter file other than dfile_rall.1D (the default generated in the volreg block).  Note: such files no longer need to be copied via -copy_files.  If the motion file is in a remote directory, include the path, e.g. -regress_motion_file ../subject17/data/motion.1D .",
            "id": "__REGRESS_MOTION_FILE__",
            "name": "__REGRESS_MOTION_FILE__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_MOTION_FILE__"
        },
        {
            "command-line-flag": "-regress_no_fitts",
            "description": "do not supply -fitts to 3dDeconvolve  e.g. -regress_no_fitts  This option prevents the program from adding a -fitts option to the 3dDeconvolve command in the output script.  See also -regress_fitts_prefix.",
            "id": "__REGRESS_NO_FITTS__",
            "name": "__REGRESS_NO_FITTS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_NO_FITTS__"
        },
        {
            "command-line-flag": "-regress_no_ideal_sum",
            "description": "do not create sum_ideal.1D from regressors  By default, afni_proc.py will compute a 'sum_ideal.1D' file that is the sum of non-polort and non-motion regressors from the X-matrix.  This option prevents that step.  See also -regress_make_ideal_sum.",
            "id": "__REGRESS_NO_IDEAL_SUM__",
            "name": "__REGRESS_NO_IDEAL_SUM__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_NO_IDEAL_SUM__"
        },
        {
            "command-line-flag": "-regress_no_ideals",
            "description": "do not generate ideal response curves  e.g. -regress_no_ideals  By default, if the GAM or BLOCK basis function is used, ideal response curve files are generated for each stimulus type (from the output X matrix using '3dDeconvolve -x1D').  The names of the ideal response function files look like 'ideal_LABEL.1D', for each stimulus label, LABEL.  This option is used to suppress generation of those files.  See also -regress_basis, -regress_stim_labels.",
            "id": "__REGRESS_NO_IDEALS__",
            "name": "__REGRESS_NO_IDEALS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_NO_IDEALS__"
        },
        {
            "command-line-flag": "-regress_no_iresp",
            "description": "do not supply -iresp to 3dDeconvolve  e.g. -regress_no_iresp  This option prevents the program from adding a set of -iresp options to the 3dDeconvolve command in the output script.  By default -iresp will be used unless the basis function is GAM.  See also -regress_iresp_prefix, -regress_basis.",
            "id": "__REGRESS_NO_IRESP__",
            "name": "__REGRESS_NO_IRESP__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_NO_IRESP__"
        },
        {
            "command-line-flag": "-regress_no_mask",
            "description": "do not apply the mask in regression  ** This is now the default, making the option unnecessary.  This option prevents the program from applying the mask dataset in the scaling or regression steps.  If the user does not want to apply a mask in the regression analysis, but wants the full_mask dataset for other reasons (such as computing blur estimates), this option can be used.  See also -regress_est_blur_epits, -regress_est_blur_errts.",
            "id": "__REGRESS_NO_MASK__",
            "name": "__REGRESS_NO_MASK__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_NO_MASK__"
        },
        {
            "command-line-flag": "-regress_no_motion",
            "description": "do not apply motion params in 3dDeconvolve  e.g. -regress_no_motion  This option prevents the program from adding the registration parameters (from volreg) to the 3dDeconvolve command.",
            "id": "__REGRESS_NO_MOTION__",
            "name": "__REGRESS_NO_MOTION__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_NO_MOTION__"
        },
        {
            "command-line-flag": "-regress_no_motion_demean",
            "description": "do not compute de-meaned motion parameters  default: do compute them  Even if they are not applied in the regression, the default is to compute de-meaned motion parameters.  These may give the user a better idea of motion regressors, since their scale will not be affected by jumps across run breaks or multi-run drift.  This option prevents the program from even computing such motion parameters.  The only real reason to not do it is if there is some problem with the command.",
            "id": "__REGRESS_NO_MOTION_DEMEAN__",
            "name": "__REGRESS_NO_MOTION_DEMEAN__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_NO_MOTION_DEMEAN__"
        },
        {
            "command-line-flag": "-regress_no_motion_deriv",
            "description": "do not compute motion parameter derivatives  default: do compute them  Even if they are not applied in the regression, the default is to compute motion parameter derivatives (and de-mean them).  These can give the user a different idea about motion regressors, since the derivatives are a better indication of per-TR motion.  Note that the 'enorm' file that is created (and optionally used for motion censoring) is basically made by collapsing (via the Euclidean Norm - the square root of the sum of the squares) these 6 derivative columns into one.  This option prevents the program from even computing such motion parameters.  The only real reason to not do it is if there is some problem with the command.  See also -regress_censor_motion.",
            "id": "__REGRESS_NO_MOTION_DERIV__",
            "name": "__REGRESS_NO_MOTION_DERIV__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_NO_MOTION_DERIV__"
        },
        {
            "command-line-flag": "-regress_opts_reml",
            "description": "-regress_opts_reml OPTS ...  : specify extra options for 3dREMLfit  e.g. -regress_opts_reml                                 \\ -gltsym ../contr/contrast1.txt FACEvsDONUT      \\ -MAXa 0.92  This option allows the user to add extra options to the 3dREMLfit command.  Note that only one -regress_opts_reml should be applied, which may be used for multiple 3dREMLfit options.  Please see '3dREMLfit -help' for more information.",
            "id": "__REGRESS_OPTS_REML__",
            "name": "__REGRESS_OPTS_REML__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_OPTS_REML__"
        },
        {
            "command-line-flag": "-regress_polort",
            "description": "specify the polynomial degree of baseline  e.g. -regress_polort 2 default: 1 + floor(run_length / 150.0)  3dDeconvolve models the baseline for each run separately, using Legendre polynomials (by default).  This option specifies the degree of polynomial.  Note that this will create DEGREE * NRUNS regressors.  The default is computed from the length of a run, in seconds, as shown above.  For example, if each run were 320 seconds, then the default polort would be 3 (cubic).  Please see '3dDeconvolve -help' for more information.",
            "id": "__REGRESS_POLORT__",
            "name": "__REGRESS_POLORT__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_POLORT__"
        },
        {
            "command-line-flag": "-regress_reml_exec",
            "description": "execute 3dREMLfit, matching 3dDeconvolve cmd  3dDeconvolve automatically creates a 3dREMLfit command script to match the regression model of 3dDeconvolve.  Via this option, the user can have that command executed.  Note that the X-matrix used in 3dREMLfit is actually generated by 3dDeconvolve.  The 3dDeconvolve command generates both the X-matrix and the 3dREMLfit command script, and so it must be run regardless of whether it actually performs the regression.  To terminate 3dDeconvolve after creation of the X-matrix and 3dREMLfit command script, apply -regress_3dD_stop.  See also -regress_3dD_stop.",
            "id": "__REGRESS_REML_EXEC__",
            "name": "__REGRESS_REML_EXEC__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_REML_EXEC__"
        },
        {
            "command-line-flag": "-regress_ROI_PC",
            "description": "regress out PCs within mask  e.g. -regress_ROI_PC vent 3",
            "id": "__REGRESS_ROI_PC__",
            "name": "__REGRESS_ROI_PC__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_ROI_PC__"
        },
        {
            "command-line-flag": "-regress_RSFC",
            "description": "perform bandpassing via 3dRSFC  Use this option flag to run 3dRSFC after the linear regression step (presumably to clean resting state data).  Along with the bandpassed data, 3dRSFC will produce connectivity parameters, saved in the RSFC directory by the proc script.  The -regress_bandpass option is required, and those bands will be passed directly to 3dRSFC.  Since bandpassing will be done only after the linear regression, censoring is not advisable.  See also -regress_bandpass, -regress_censor_motion. Please see '3dRSFC -help' for more information.",
            "id": "__REGRESS_RSFC__",
            "name": "__REGRESS_RSFC__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_RSFC__"
        },
        {
            "command-line-flag": "-regress_RONI",
            "description": "-regress_RONI IND1 ...  : specify a list of regressors of no interest  e.g. -regress_RONI 1 17 22  Use this option flag regressors as ones of no interest, meaning they are applied to the baseline (for full-F) and the corresponding beta weights are not output (by default at least).  The indices in the list should match those given to 3dDeconvolve. They start at 1 first with the main regressors, and then with any extra regressors (given via -regress_extra_stim_files).  Note that these do not apply to motion regressors.  The user is encouraged to check the 3dDeconvolve command in the processing script, to be sure they are applied correctly.",
            "id": "__REGRESS_RONI__",
            "name": "__REGRESS_RONI__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_RONI__"
        },
        {
            "command-line-flag": "-regress_extra_stim_files",
            "description": "-regress_extra_stim_files FILE1 ... : specify extra stim files  e.g. -regress_extra_stim_files resp.1D cardiac.1D e.g. -regress_extra_stim_files regs_of_no_int_*.1D  Use this option to specify extra files to be applied with the",
            "id": "__REGRESS_EXTRA_STIM_FILES__",
            "name": "__REGRESS_EXTRA_STIM_FILES__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_EXTRA_STIM_FILES__"
        },
        {
            "command-line-flag": "-regress_extra_stim_labels",
            "description": "-regress_extra_stim_labels LAB1 ... : specify extra stim file labels  e.g. -regress_extra_stim_labels resp cardiac  If -regress_extra_stim_files is given, the user may want to specify labels for those extra stimulus files.  This option provides that mechanism.  If this option is not given, default labels will be assigned (like stim17, for example).  Note that the number of entries in this list should match the number of extra stim files.  See also -regress_extra_stim_files.",
            "id": "__REGRESS_EXTRA_STIM_LABELS__",
            "name": "__REGRESS_EXTRA_STIM_LABELS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_EXTRA_STIM_LABELS__"
        },
        {
            "command-line-flag": "-regress_stim_times_offset",
            "description": "add OFFSET to -stim_times files  e.g. -regress_stim_times_offset 1.25 e.g. -regress_stim_times_offset -9.2 default: 0  With -regress_stim_times:  If the -regress_stim_times option is uses, and if ALL stim files are timing files, then timing_tool.py will be used to add the time offset to each -regress_stim_times file as it is copied into the stimuli directory (near the beginning of the script).  With -regress_stim_files:  If the -regress_stim_files option is used (so the script would convert -stim_files to -stim_times before 3dDeconvolve), the user may want to add an offset to the times in the resulting timing files.  For example, if -tshift_align_to is applied and the user chooses to align volumes to the middle of the TR, it might be appropriate to add TR/2 to the times of the stim_times files.  This OFFSET will be applied to the make_stim_times.py command in the output script.  Please see 'make_stim_times.py -help' for more information. See also -regress_stim_files, -regress_use_stim_files,",
            "id": "__REGRESS_STIM_TIMES_OFFSET__",
            "name": "__REGRESS_STIM_TIMES_OFFSET__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_STIM_TIMES_OFFSET__"
        },
        {
            "command-line-flag": "-regress_use_stim_files",
            "description": "use -stim_file in regression, not -stim_times  The default operation of afni_proc.py is to convert TR-locked files for the 3dDeconvolve -stim_file option to timing files for the 3dDeconvolve -stim_times option.  If the -regress_use_stim_times option is provided, then no such conversion will take place.  This assumes the -regress_stim_files option is applied to provide such -stim_file files.  This option has been renamed from '-regress_no_stim_times'.  Please see '3dDeconvolve -help' for more information. See also -regress_stim_files, -regress_stim_times,",
            "id": "__REGRESS_USE_STIM_FILES__",
            "name": "__REGRESS_USE_STIM_FILES__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_USE_STIM_FILES__"
        },
        {
            "command-line-flag": "-regress_opts_CS",
            "description": "-regress_opts_CS.",
            "id": "__REGRESS_OPTS_CS__",
            "name": "__REGRESS_OPTS_CS__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_OPTS_CS__"
        },
        {
            "command-line-flag": "-regress_CS_NN",
            "description": "specify NN levels for 3dClustSim command  e.g.     -regress_CS_NN 1 default: -regress_CS_NN 123  This option allows the user to specify which nearest neighbors to consider when clustering.  Cluster results will be generated for each included NN level.  Using multiple levels means being able to choose between those same levels when looking at the statistical results using the afni GUI.  The LEVELS should be chosen from the set {1,2,3}, where the respective levels mean \"shares a face\", \"shares an edge\" and \"shares a corner\", respectively.  Any non-empty subset can be used. They should be specified as is with 3dClustSim.  So there are 7 valid subsets: 1, 2, 3, 12, 13, 23, and 123.  Please see '3dClustSim -help' for details on its '-NN' option.",
            "id": "__REGRESS_CS_NN__",
            "name": "__REGRESS_CS_NN__",
            "optional": true,
            "type": "String",
            "value-key": "__REGRESS_CS_NN__"
        }
    ],
    "name": "tool name",
    "schema-version": "0.5",
    "suggested-resources": {
        "cpu-cores": 1,
        "ram": 1,
        "walltime-estimate": 60
    },
    "tags": {},
    "tool-version": "v0.1.0"
}