"""
Functions for generating boutiques descriptors from AFNI help
"""
import argparse
import json
from pathlib import Path
import re
import boutiques.creator as bc

ALPHANUM = re.compile("[\W_]+")
FINDARGS = re.compile("ARGS=\((.*) ?\)")
FINDHELP = re.compile('\s*(-[\s\S]*)[=:}][\s\S]')


def get_complete_args(fname):
    """
    Attempts to find arguments for a given AFNI command

    Parameters
    ----------
    fname : str
        Path to "COMMAND.complete.bash" file generated by running
        `apsearch -update_all_afni_help`

    Returns
    -------
    args : list of str
        Putative arguments for command defined by `fname`
    """
    fpath = Path(fname).expanduser()
    if not fpath.exists():
        raise FileNotFoundError('{} does not seem to exist?'.format(fname))

    args = FINDARGS.findall(fpath.read_text())
    if len(args) < 1:
        raise ValueError('Unable to find arguments for {}'.format(fname))
    args = args[0].strip().replace('\'', '').split(' ')

    return args


def get_complete_help(fname, putative=None):
    """
    Parameters
    ----------
    fname : str
        Path to full helptext for a given AFNI command

    Returns
    -------
    description : str
        Primary description of tool in `fname`
    arghelps : list of str
        List of descriptions
    """
    helptext = Path(fname).read_text().splitlines()
    params = []
    # grab parameters and line starts
    for n, f in enumerate(helptext):
        if FINDHELP.match(f) is None:
            continue
        param = FINDHELP.findall(f)[0].strip()
        params += [dict(param=param, line_start=n, length=None)]

    # compare to list of putative arguments and
    if putative is not None:
        pass

    # update potential lengths of help text
    for n, f in enumerate(params):
        try:
            length = params[n + 1].get('line_start') - f.get('line_start')
        except IndexError:
            length = None
        params[n]['length'] = length

    return params, helptext


def gen_args_dict(help_dir, outfile='output.json'):
    """
    Generates JSON `outfile` of AFNI commands and arguments in `help_dir`

    Parameters
    ----------
    help_dir : str
        Path to directory with AFNI help files
    outfile : str
        Path to desired output file

    Returns
    -------
    outfile : str
        Path to output JSON file
    """
    help_dir = Path(help_dir)
    tools = help_dir.glob('*.complete.bash')
    args_dict = {}
    for tool in tools:
        in_args = get_complete_args(tool)
        tool_name = tool.name.replace('.complete.bash', '')
        args_dict[tool_name] = in_args

    with open(outfile, 'w') as dest:
        json.dump(args_dict, dest)

    return outfile


def gen_boutiques_descriptor(args_json, outdir='afni_boutiques'):
    """
    Writes boutiques descriptors to `outdir` for AFNI commands in `args_json`

    Parameters
    ----------
    args_json : str
        Filepath to JSON dictionary containing AFNI commands and putative
        arguments

    Returns
    -------
    descriptors : list
        List of paths to generated boutiques descriptor JSON files
    """
    with open(args_json) as src:
        afni = json.load(src)

    out_path = Path(outdir).resolve()
    out_path.mkdir(exist_ok=True)

    descriptors = []
    # iterate through all afni command / argument pairs and generate boutique
    # descriptor files for each,
    for cmd, args in afni.items():
        out_fname = out_path.joinpath('{}.json'.format(cmd))
        parser = argparse.ArgumentParser(add_help=False)
        for arg in args:
            arg = '-' + ALPHANUM.sub('', arg)
            # ensure argument not already in parser (and not invalid / empty)
            if arg.strip('-') not in [f.dest for f in parser._actions] + ['']:
                kwargs = {'required': True} if arg == '-input' else {}
                parser.add_argument(arg, type=str, help='NA', **kwargs)
        bout = bc.CreateDescriptor(parser, execname=cmd)
        bout.save(out_fname)
        descriptors.append(out_fname.as_posix())

    return descriptors
