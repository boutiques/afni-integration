"""
Functions for generating boutiques descriptors from AFNI help
"""
import argparse
import json
from pathlib import Path
import re
import boutiques.creator as bc

ALPHANUM = re.compile("[\W_]+")
FINDARGS = re.compile("ARGS=\((.*) ?\)")
FINDHELP = re.compile('\s*(-[\s\S]*)[=:}][\s\S]')


def get_complete_args(fname):
    """
    Attempts to find arguments for a given AFNI command

    Parameters
    ----------
    fname : str
        Path to "COMMAND.complete.bash" file generated by running
        `apsearch -update_all_afni_help`

    Returns
    -------
    args : list of str
        Putative arguments for command defined by `fname`
    """
    fpath = Path(fname).expanduser()
    if not fpath.exists():
        raise FileNotFoundError('{} does not seem to exist?'.format(fname))

    args = FINDARGS.findall(fpath.read_text())
    if len(args) < 1:
        raise ValueError('Unable to find arguments for {}'.format(fname))
    args = args[0].strip().replace('\'', '').split(' ')

    return args


def get_help_info(fname, putative=None):
    """
    Gets command arguments and line number in help text for command in `fname`

    Parameters
    ----------
    fname : str
        Path to full helptext for a given AFNI command
    putative : list of str
        List of putative argument for a given AFNI command

    Returns
    -------
    description : str
        Primary description of tool in `fname`
    arghelps : list of str
        List of descriptions
    """
    helptext = Path(fname).read_text().splitlines()
    params = []
    # grab parameters and line starts
    for n, f in enumerate(helptext):
        if FINDHELP.match(f) is None:
            continue
        param = FINDHELP.findall(f)[0].strip().split(' ')[0]
        params += [dict(param=param, line_start=n, length=None)]

    # compare to list of putative arguments
    if putative is not None:
        missing = list(set(putative) - set([p.get('param') for p in params]))
        for miss in missing:
            for n, f in enumerate(helptext):
                if f.strip().startswith(miss):
                    if n not in [p.get('line_start') for p in params]:
                        params += [dict(param=miss, line_start=n, length=None)]
    params = sorted(params, key=lambda x: x.get('line_start'))

    # update potential lengths of help text
    for n, f in enumerate(params[:-1]):
        params[n]['length'] = (params[n + 1].get('line_start') -
                               f.get('line_start'))

    return params, helptext


def gen_tool_dict(help_dir, outdir=None):
    """
    Generates individual JSON files for each AFNI command in `help_dir`

    Output JSON files contain:
        1. Entire helptext for command, split into lines
        2. List of putative parameters for command, including starting line in
           help text and length of description

    Parameters
    ----------
    help_dir : str
        Path to directory with AFNI help files
    outdir : str
        Path to where output JSON files should be saved

    Returns
    -------
    jsons : list of str
        Paths to saved JSON files
    """
    if outdir is None:
        outdir = Path('.').resolve()
    outdir = Path(outdir)
    outdir.mkdir(exist_ok=True)
    help_dir = Path(help_dir)
    jsons = []

    # iterate through tools and get help information
    for tool in help_dir.glob('*.complete.bash'):
        tool_name = tool.name.replace('.complete.bash', '')
        help_fnames = help_dir.glob(tool_name + '.????_??_??-??_??_??.help')
        params, helptext = get_help_info(sorted(help_fnames)[-1],
                                         putative=get_complete_args(tool))
        jsons.append(outdir.joinpath('{}.json'.format(tool_name)).as_posix())
        # save to ugly json
        with open(jsons[-1], 'w') as dest:
            json.dump(dict(helptext=helptext, params=params), dest)

    return jsons


def gen_args_dict(help_dir, outfile='allhelp.json'):
    """
    Generates JSON `outfile` of AFNI commands and arguments in `help_dir`

    Parameters
    ----------
    help_dir : str
        Path to directory with AFNI help files
    outfile : str
        Path to desired output file

    Returns
    -------
    outfile : str
        Path to output JSON file
    """
    help_dir = Path(help_dir)
    args_dict = {}
    for tool in help_dir.glob('*.complete.bash'):
        tool_name = tool.name.replace('.complete.bash', '')
        args_dict[tool_name] = get_complete_args(tool)

    with open(outfile, 'w') as dest:
        json.dump(args_dict, dest)

    return outfile


def gen_boutiques_descriptor(args_json, outdir='afni_boutiques'):
    """
    Writes boutiques descriptors to `outdir` for AFNI commands in `args_json`

    Parameters
    ----------
    args_json : str
        Filepath to JSON dictionary containing AFNI commands and putative
        arguments

    Returns
    -------
    descriptors : list
        List of paths to generated boutiques descriptor JSON files
    """
    with open(args_json) as src:
        afni = json.load(src)

    out_path = Path(outdir).resolve()
    out_path.mkdir(exist_ok=True)

    descriptors = []
    # iterate through all afni command / argument pairs and generate boutique
    # descriptor files for each,
    for cmd, args in afni.items():
        out_fname = out_path.joinpath('{}.json'.format(cmd))
        parser = argparse.ArgumentParser(add_help=False)
        for arg in args:
            arg = '-' + ALPHANUM.sub('', arg)
            # ensure argument not already in parser (and not invalid / empty)
            if arg.strip('-') not in [f.dest for f in parser._actions] + ['']:
                kwargs = {'required': True} if arg == '-input' else {}
                parser.add_argument(arg, type=str, help='NA', **kwargs)
        bout = bc.CreateDescriptor(parser, execname=cmd)
        bout.save(out_fname)
        descriptors.append(out_fname.as_posix())

    return descriptors
